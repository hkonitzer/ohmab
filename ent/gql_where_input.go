// OHMAB
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/hkonitzer/ohmab/ent/address"
	"github.com/hkonitzer/ohmab/ent/auditlog"
	"github.com/hkonitzer/ohmab/ent/business"
	"github.com/hkonitzer/ohmab/ent/content"
	"github.com/hkonitzer/ohmab/ent/predicate"
	"github.com/hkonitzer/ohmab/ent/tag"
	"github.com/hkonitzer/ohmab/ent/timetable"
	"github.com/hkonitzer/ohmab/ent/user"
)

// AddressWhereInput represents a where input for filtering Address queries.
type AddressWhereInput struct {
	Predicates []predicate.Address  `json:"-"`
	Not        *AddressWhereInput   `json:"not,omitempty"`
	Or         []*AddressWhereInput `json:"or,omitempty"`
	And        []*AddressWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "addition" field predicates.
	Addition             *string  `json:"addition,omitempty"`
	AdditionNEQ          *string  `json:"additionNEQ,omitempty"`
	AdditionIn           []string `json:"additionIn,omitempty"`
	AdditionNotIn        []string `json:"additionNotIn,omitempty"`
	AdditionGT           *string  `json:"additionGT,omitempty"`
	AdditionGTE          *string  `json:"additionGTE,omitempty"`
	AdditionLT           *string  `json:"additionLT,omitempty"`
	AdditionLTE          *string  `json:"additionLTE,omitempty"`
	AdditionContains     *string  `json:"additionContains,omitempty"`
	AdditionHasPrefix    *string  `json:"additionHasPrefix,omitempty"`
	AdditionHasSuffix    *string  `json:"additionHasSuffix,omitempty"`
	AdditionIsNil        bool     `json:"additionIsNil,omitempty"`
	AdditionNotNil       bool     `json:"additionNotNil,omitempty"`
	AdditionEqualFold    *string  `json:"additionEqualFold,omitempty"`
	AdditionContainsFold *string  `json:"additionContainsFold,omitempty"`

	// "street" field predicates.
	Street             *string  `json:"street,omitempty"`
	StreetNEQ          *string  `json:"streetNEQ,omitempty"`
	StreetIn           []string `json:"streetIn,omitempty"`
	StreetNotIn        []string `json:"streetNotIn,omitempty"`
	StreetGT           *string  `json:"streetGT,omitempty"`
	StreetGTE          *string  `json:"streetGTE,omitempty"`
	StreetLT           *string  `json:"streetLT,omitempty"`
	StreetLTE          *string  `json:"streetLTE,omitempty"`
	StreetContains     *string  `json:"streetContains,omitempty"`
	StreetHasPrefix    *string  `json:"streetHasPrefix,omitempty"`
	StreetHasSuffix    *string  `json:"streetHasSuffix,omitempty"`
	StreetIsNil        bool     `json:"streetIsNil,omitempty"`
	StreetNotNil       bool     `json:"streetNotNil,omitempty"`
	StreetEqualFold    *string  `json:"streetEqualFold,omitempty"`
	StreetContainsFold *string  `json:"streetContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityIsNil        bool     `json:"cityIsNil,omitempty"`
	CityNotNil       bool     `json:"cityNotNil,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "zip" field predicates.
	Zip             *string  `json:"zip,omitempty"`
	ZipNEQ          *string  `json:"zipNEQ,omitempty"`
	ZipIn           []string `json:"zipIn,omitempty"`
	ZipNotIn        []string `json:"zipNotIn,omitempty"`
	ZipGT           *string  `json:"zipGT,omitempty"`
	ZipGTE          *string  `json:"zipGTE,omitempty"`
	ZipLT           *string  `json:"zipLT,omitempty"`
	ZipLTE          *string  `json:"zipLTE,omitempty"`
	ZipContains     *string  `json:"zipContains,omitempty"`
	ZipHasPrefix    *string  `json:"zipHasPrefix,omitempty"`
	ZipHasSuffix    *string  `json:"zipHasSuffix,omitempty"`
	ZipIsNil        bool     `json:"zipIsNil,omitempty"`
	ZipNotNil       bool     `json:"zipNotNil,omitempty"`
	ZipEqualFold    *string  `json:"zipEqualFold,omitempty"`
	ZipContainsFold *string  `json:"zipContainsFold,omitempty"`

	// "state" field predicates.
	State             *string  `json:"state,omitempty"`
	StateNEQ          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGT           *string  `json:"stateGT,omitempty"`
	StateGTE          *string  `json:"stateGTE,omitempty"`
	StateLT           *string  `json:"stateLT,omitempty"`
	StateLTE          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateIsNil        bool     `json:"stateIsNil,omitempty"`
	StateNotNil       bool     `json:"stateNotNil,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryIsNil        bool     `json:"countryIsNil,omitempty"`
	CountryNotNil       bool     `json:"countryNotNil,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "locale" field predicates.
	Locale             *string  `json:"locale,omitempty"`
	LocaleNEQ          *string  `json:"localeNEQ,omitempty"`
	LocaleIn           []string `json:"localeIn,omitempty"`
	LocaleNotIn        []string `json:"localeNotIn,omitempty"`
	LocaleGT           *string  `json:"localeGT,omitempty"`
	LocaleGTE          *string  `json:"localeGTE,omitempty"`
	LocaleLT           *string  `json:"localeLT,omitempty"`
	LocaleLTE          *string  `json:"localeLTE,omitempty"`
	LocaleContains     *string  `json:"localeContains,omitempty"`
	LocaleHasPrefix    *string  `json:"localeHasPrefix,omitempty"`
	LocaleHasSuffix    *string  `json:"localeHasSuffix,omitempty"`
	LocaleEqualFold    *string  `json:"localeEqualFold,omitempty"`
	LocaleContainsFold *string  `json:"localeContainsFold,omitempty"`

	// "primary" field predicates.
	Primary    *bool `json:"primary,omitempty"`
	PrimaryNEQ *bool `json:"primaryNEQ,omitempty"`

	// "telephone" field predicates.
	Telephone             *string  `json:"telephone,omitempty"`
	TelephoneNEQ          *string  `json:"telephoneNEQ,omitempty"`
	TelephoneIn           []string `json:"telephoneIn,omitempty"`
	TelephoneNotIn        []string `json:"telephoneNotIn,omitempty"`
	TelephoneGT           *string  `json:"telephoneGT,omitempty"`
	TelephoneGTE          *string  `json:"telephoneGTE,omitempty"`
	TelephoneLT           *string  `json:"telephoneLT,omitempty"`
	TelephoneLTE          *string  `json:"telephoneLTE,omitempty"`
	TelephoneContains     *string  `json:"telephoneContains,omitempty"`
	TelephoneHasPrefix    *string  `json:"telephoneHasPrefix,omitempty"`
	TelephoneHasSuffix    *string  `json:"telephoneHasSuffix,omitempty"`
	TelephoneIsNil        bool     `json:"telephoneIsNil,omitempty"`
	TelephoneNotNil       bool     `json:"telephoneNotNil,omitempty"`
	TelephoneEqualFold    *string  `json:"telephoneEqualFold,omitempty"`
	TelephoneContainsFold *string  `json:"telephoneContainsFold,omitempty"`

	// "comment" field predicates.
	Comment             *string  `json:"comment,omitempty"`
	CommentNEQ          *string  `json:"commentNEQ,omitempty"`
	CommentIn           []string `json:"commentIn,omitempty"`
	CommentNotIn        []string `json:"commentNotIn,omitempty"`
	CommentGT           *string  `json:"commentGT,omitempty"`
	CommentGTE          *string  `json:"commentGTE,omitempty"`
	CommentLT           *string  `json:"commentLT,omitempty"`
	CommentLTE          *string  `json:"commentLTE,omitempty"`
	CommentContains     *string  `json:"commentContains,omitempty"`
	CommentHasPrefix    *string  `json:"commentHasPrefix,omitempty"`
	CommentHasSuffix    *string  `json:"commentHasSuffix,omitempty"`
	CommentIsNil        bool     `json:"commentIsNil,omitempty"`
	CommentNotNil       bool     `json:"commentNotNil,omitempty"`
	CommentEqualFold    *string  `json:"commentEqualFold,omitempty"`
	CommentContainsFold *string  `json:"commentContainsFold,omitempty"`

	// "business" edge predicates.
	HasBusiness     *bool                 `json:"hasBusiness,omitempty"`
	HasBusinessWith []*BusinessWhereInput `json:"hasBusinessWith,omitempty"`

	// "timetables" edge predicates.
	HasTimetables     *bool                  `json:"hasTimetables,omitempty"`
	HasTimetablesWith []*TimetableWhereInput `json:"hasTimetablesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AddressWhereInput) AddPredicates(predicates ...predicate.Address) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AddressWhereInput filter on the AddressQuery builder.
func (i *AddressWhereInput) Filter(q *AddressQuery) (*AddressQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAddressWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAddressWhereInput is returned in case the AddressWhereInput is empty.
var ErrEmptyAddressWhereInput = errors.New("ent: empty predicate AddressWhereInput")

// P returns a predicate for filtering addresses.
// An error is returned if the input is empty or invalid.
func (i *AddressWhereInput) P() (predicate.Address, error) {
	var predicates []predicate.Address
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, address.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Address, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, address.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Address, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, address.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, address.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, address.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, address.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, address.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, address.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, address.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, address.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, address.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, address.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, address.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, address.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, address.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, address.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, address.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, address.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, address.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, address.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, address.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, address.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, address.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, address.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, address.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, address.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, address.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, address.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, address.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, address.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, address.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, address.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, address.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, address.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, address.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, address.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, address.DeletedAtNotNil())
	}
	if i.Addition != nil {
		predicates = append(predicates, address.AdditionEQ(*i.Addition))
	}
	if i.AdditionNEQ != nil {
		predicates = append(predicates, address.AdditionNEQ(*i.AdditionNEQ))
	}
	if len(i.AdditionIn) > 0 {
		predicates = append(predicates, address.AdditionIn(i.AdditionIn...))
	}
	if len(i.AdditionNotIn) > 0 {
		predicates = append(predicates, address.AdditionNotIn(i.AdditionNotIn...))
	}
	if i.AdditionGT != nil {
		predicates = append(predicates, address.AdditionGT(*i.AdditionGT))
	}
	if i.AdditionGTE != nil {
		predicates = append(predicates, address.AdditionGTE(*i.AdditionGTE))
	}
	if i.AdditionLT != nil {
		predicates = append(predicates, address.AdditionLT(*i.AdditionLT))
	}
	if i.AdditionLTE != nil {
		predicates = append(predicates, address.AdditionLTE(*i.AdditionLTE))
	}
	if i.AdditionContains != nil {
		predicates = append(predicates, address.AdditionContains(*i.AdditionContains))
	}
	if i.AdditionHasPrefix != nil {
		predicates = append(predicates, address.AdditionHasPrefix(*i.AdditionHasPrefix))
	}
	if i.AdditionHasSuffix != nil {
		predicates = append(predicates, address.AdditionHasSuffix(*i.AdditionHasSuffix))
	}
	if i.AdditionIsNil {
		predicates = append(predicates, address.AdditionIsNil())
	}
	if i.AdditionNotNil {
		predicates = append(predicates, address.AdditionNotNil())
	}
	if i.AdditionEqualFold != nil {
		predicates = append(predicates, address.AdditionEqualFold(*i.AdditionEqualFold))
	}
	if i.AdditionContainsFold != nil {
		predicates = append(predicates, address.AdditionContainsFold(*i.AdditionContainsFold))
	}
	if i.Street != nil {
		predicates = append(predicates, address.StreetEQ(*i.Street))
	}
	if i.StreetNEQ != nil {
		predicates = append(predicates, address.StreetNEQ(*i.StreetNEQ))
	}
	if len(i.StreetIn) > 0 {
		predicates = append(predicates, address.StreetIn(i.StreetIn...))
	}
	if len(i.StreetNotIn) > 0 {
		predicates = append(predicates, address.StreetNotIn(i.StreetNotIn...))
	}
	if i.StreetGT != nil {
		predicates = append(predicates, address.StreetGT(*i.StreetGT))
	}
	if i.StreetGTE != nil {
		predicates = append(predicates, address.StreetGTE(*i.StreetGTE))
	}
	if i.StreetLT != nil {
		predicates = append(predicates, address.StreetLT(*i.StreetLT))
	}
	if i.StreetLTE != nil {
		predicates = append(predicates, address.StreetLTE(*i.StreetLTE))
	}
	if i.StreetContains != nil {
		predicates = append(predicates, address.StreetContains(*i.StreetContains))
	}
	if i.StreetHasPrefix != nil {
		predicates = append(predicates, address.StreetHasPrefix(*i.StreetHasPrefix))
	}
	if i.StreetHasSuffix != nil {
		predicates = append(predicates, address.StreetHasSuffix(*i.StreetHasSuffix))
	}
	if i.StreetIsNil {
		predicates = append(predicates, address.StreetIsNil())
	}
	if i.StreetNotNil {
		predicates = append(predicates, address.StreetNotNil())
	}
	if i.StreetEqualFold != nil {
		predicates = append(predicates, address.StreetEqualFold(*i.StreetEqualFold))
	}
	if i.StreetContainsFold != nil {
		predicates = append(predicates, address.StreetContainsFold(*i.StreetContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, address.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, address.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, address.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, address.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, address.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, address.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, address.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, address.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, address.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, address.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, address.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityIsNil {
		predicates = append(predicates, address.CityIsNil())
	}
	if i.CityNotNil {
		predicates = append(predicates, address.CityNotNil())
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, address.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, address.CityContainsFold(*i.CityContainsFold))
	}
	if i.Zip != nil {
		predicates = append(predicates, address.ZipEQ(*i.Zip))
	}
	if i.ZipNEQ != nil {
		predicates = append(predicates, address.ZipNEQ(*i.ZipNEQ))
	}
	if len(i.ZipIn) > 0 {
		predicates = append(predicates, address.ZipIn(i.ZipIn...))
	}
	if len(i.ZipNotIn) > 0 {
		predicates = append(predicates, address.ZipNotIn(i.ZipNotIn...))
	}
	if i.ZipGT != nil {
		predicates = append(predicates, address.ZipGT(*i.ZipGT))
	}
	if i.ZipGTE != nil {
		predicates = append(predicates, address.ZipGTE(*i.ZipGTE))
	}
	if i.ZipLT != nil {
		predicates = append(predicates, address.ZipLT(*i.ZipLT))
	}
	if i.ZipLTE != nil {
		predicates = append(predicates, address.ZipLTE(*i.ZipLTE))
	}
	if i.ZipContains != nil {
		predicates = append(predicates, address.ZipContains(*i.ZipContains))
	}
	if i.ZipHasPrefix != nil {
		predicates = append(predicates, address.ZipHasPrefix(*i.ZipHasPrefix))
	}
	if i.ZipHasSuffix != nil {
		predicates = append(predicates, address.ZipHasSuffix(*i.ZipHasSuffix))
	}
	if i.ZipIsNil {
		predicates = append(predicates, address.ZipIsNil())
	}
	if i.ZipNotNil {
		predicates = append(predicates, address.ZipNotNil())
	}
	if i.ZipEqualFold != nil {
		predicates = append(predicates, address.ZipEqualFold(*i.ZipEqualFold))
	}
	if i.ZipContainsFold != nil {
		predicates = append(predicates, address.ZipContainsFold(*i.ZipContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, address.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, address.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, address.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, address.StateNotIn(i.StateNotIn...))
	}
	if i.StateGT != nil {
		predicates = append(predicates, address.StateGT(*i.StateGT))
	}
	if i.StateGTE != nil {
		predicates = append(predicates, address.StateGTE(*i.StateGTE))
	}
	if i.StateLT != nil {
		predicates = append(predicates, address.StateLT(*i.StateLT))
	}
	if i.StateLTE != nil {
		predicates = append(predicates, address.StateLTE(*i.StateLTE))
	}
	if i.StateContains != nil {
		predicates = append(predicates, address.StateContains(*i.StateContains))
	}
	if i.StateHasPrefix != nil {
		predicates = append(predicates, address.StateHasPrefix(*i.StateHasPrefix))
	}
	if i.StateHasSuffix != nil {
		predicates = append(predicates, address.StateHasSuffix(*i.StateHasSuffix))
	}
	if i.StateIsNil {
		predicates = append(predicates, address.StateIsNil())
	}
	if i.StateNotNil {
		predicates = append(predicates, address.StateNotNil())
	}
	if i.StateEqualFold != nil {
		predicates = append(predicates, address.StateEqualFold(*i.StateEqualFold))
	}
	if i.StateContainsFold != nil {
		predicates = append(predicates, address.StateContainsFold(*i.StateContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, address.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, address.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, address.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, address.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, address.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, address.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, address.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, address.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, address.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, address.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, address.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryIsNil {
		predicates = append(predicates, address.CountryIsNil())
	}
	if i.CountryNotNil {
		predicates = append(predicates, address.CountryNotNil())
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, address.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, address.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Locale != nil {
		predicates = append(predicates, address.LocaleEQ(*i.Locale))
	}
	if i.LocaleNEQ != nil {
		predicates = append(predicates, address.LocaleNEQ(*i.LocaleNEQ))
	}
	if len(i.LocaleIn) > 0 {
		predicates = append(predicates, address.LocaleIn(i.LocaleIn...))
	}
	if len(i.LocaleNotIn) > 0 {
		predicates = append(predicates, address.LocaleNotIn(i.LocaleNotIn...))
	}
	if i.LocaleGT != nil {
		predicates = append(predicates, address.LocaleGT(*i.LocaleGT))
	}
	if i.LocaleGTE != nil {
		predicates = append(predicates, address.LocaleGTE(*i.LocaleGTE))
	}
	if i.LocaleLT != nil {
		predicates = append(predicates, address.LocaleLT(*i.LocaleLT))
	}
	if i.LocaleLTE != nil {
		predicates = append(predicates, address.LocaleLTE(*i.LocaleLTE))
	}
	if i.LocaleContains != nil {
		predicates = append(predicates, address.LocaleContains(*i.LocaleContains))
	}
	if i.LocaleHasPrefix != nil {
		predicates = append(predicates, address.LocaleHasPrefix(*i.LocaleHasPrefix))
	}
	if i.LocaleHasSuffix != nil {
		predicates = append(predicates, address.LocaleHasSuffix(*i.LocaleHasSuffix))
	}
	if i.LocaleEqualFold != nil {
		predicates = append(predicates, address.LocaleEqualFold(*i.LocaleEqualFold))
	}
	if i.LocaleContainsFold != nil {
		predicates = append(predicates, address.LocaleContainsFold(*i.LocaleContainsFold))
	}
	if i.Primary != nil {
		predicates = append(predicates, address.PrimaryEQ(*i.Primary))
	}
	if i.PrimaryNEQ != nil {
		predicates = append(predicates, address.PrimaryNEQ(*i.PrimaryNEQ))
	}
	if i.Telephone != nil {
		predicates = append(predicates, address.TelephoneEQ(*i.Telephone))
	}
	if i.TelephoneNEQ != nil {
		predicates = append(predicates, address.TelephoneNEQ(*i.TelephoneNEQ))
	}
	if len(i.TelephoneIn) > 0 {
		predicates = append(predicates, address.TelephoneIn(i.TelephoneIn...))
	}
	if len(i.TelephoneNotIn) > 0 {
		predicates = append(predicates, address.TelephoneNotIn(i.TelephoneNotIn...))
	}
	if i.TelephoneGT != nil {
		predicates = append(predicates, address.TelephoneGT(*i.TelephoneGT))
	}
	if i.TelephoneGTE != nil {
		predicates = append(predicates, address.TelephoneGTE(*i.TelephoneGTE))
	}
	if i.TelephoneLT != nil {
		predicates = append(predicates, address.TelephoneLT(*i.TelephoneLT))
	}
	if i.TelephoneLTE != nil {
		predicates = append(predicates, address.TelephoneLTE(*i.TelephoneLTE))
	}
	if i.TelephoneContains != nil {
		predicates = append(predicates, address.TelephoneContains(*i.TelephoneContains))
	}
	if i.TelephoneHasPrefix != nil {
		predicates = append(predicates, address.TelephoneHasPrefix(*i.TelephoneHasPrefix))
	}
	if i.TelephoneHasSuffix != nil {
		predicates = append(predicates, address.TelephoneHasSuffix(*i.TelephoneHasSuffix))
	}
	if i.TelephoneIsNil {
		predicates = append(predicates, address.TelephoneIsNil())
	}
	if i.TelephoneNotNil {
		predicates = append(predicates, address.TelephoneNotNil())
	}
	if i.TelephoneEqualFold != nil {
		predicates = append(predicates, address.TelephoneEqualFold(*i.TelephoneEqualFold))
	}
	if i.TelephoneContainsFold != nil {
		predicates = append(predicates, address.TelephoneContainsFold(*i.TelephoneContainsFold))
	}
	if i.Comment != nil {
		predicates = append(predicates, address.CommentEQ(*i.Comment))
	}
	if i.CommentNEQ != nil {
		predicates = append(predicates, address.CommentNEQ(*i.CommentNEQ))
	}
	if len(i.CommentIn) > 0 {
		predicates = append(predicates, address.CommentIn(i.CommentIn...))
	}
	if len(i.CommentNotIn) > 0 {
		predicates = append(predicates, address.CommentNotIn(i.CommentNotIn...))
	}
	if i.CommentGT != nil {
		predicates = append(predicates, address.CommentGT(*i.CommentGT))
	}
	if i.CommentGTE != nil {
		predicates = append(predicates, address.CommentGTE(*i.CommentGTE))
	}
	if i.CommentLT != nil {
		predicates = append(predicates, address.CommentLT(*i.CommentLT))
	}
	if i.CommentLTE != nil {
		predicates = append(predicates, address.CommentLTE(*i.CommentLTE))
	}
	if i.CommentContains != nil {
		predicates = append(predicates, address.CommentContains(*i.CommentContains))
	}
	if i.CommentHasPrefix != nil {
		predicates = append(predicates, address.CommentHasPrefix(*i.CommentHasPrefix))
	}
	if i.CommentHasSuffix != nil {
		predicates = append(predicates, address.CommentHasSuffix(*i.CommentHasSuffix))
	}
	if i.CommentIsNil {
		predicates = append(predicates, address.CommentIsNil())
	}
	if i.CommentNotNil {
		predicates = append(predicates, address.CommentNotNil())
	}
	if i.CommentEqualFold != nil {
		predicates = append(predicates, address.CommentEqualFold(*i.CommentEqualFold))
	}
	if i.CommentContainsFold != nil {
		predicates = append(predicates, address.CommentContainsFold(*i.CommentContainsFold))
	}

	if i.HasBusiness != nil {
		p := address.HasBusiness()
		if !*i.HasBusiness {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBusinessWith) > 0 {
		with := make([]predicate.Business, 0, len(i.HasBusinessWith))
		for _, w := range i.HasBusinessWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBusinessWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasBusinessWith(with...))
	}
	if i.HasTimetables != nil {
		p := address.HasTimetables()
		if !*i.HasTimetables {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTimetablesWith) > 0 {
		with := make([]predicate.Timetable, 0, len(i.HasTimetablesWith))
		for _, w := range i.HasTimetablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTimetablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasTimetablesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAddressWhereInput
	case 1:
		return predicates[0], nil
	default:
		return address.And(predicates...), nil
	}
}

// AuditLogWhereInput represents a where input for filtering AuditLog queries.
type AuditLogWhereInput struct {
	Predicates []predicate.AuditLog  `json:"-"`
	Not        *AuditLogWhereInput   `json:"not,omitempty"`
	Or         []*AuditLogWhereInput `json:"or,omitempty"`
	And        []*AuditLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "user" field predicates.
	User             *string  `json:"user,omitempty"`
	UserNEQ          *string  `json:"userNEQ,omitempty"`
	UserIn           []string `json:"userIn,omitempty"`
	UserNotIn        []string `json:"userNotIn,omitempty"`
	UserGT           *string  `json:"userGT,omitempty"`
	UserGTE          *string  `json:"userGTE,omitempty"`
	UserLT           *string  `json:"userLT,omitempty"`
	UserLTE          *string  `json:"userLTE,omitempty"`
	UserContains     *string  `json:"userContains,omitempty"`
	UserHasPrefix    *string  `json:"userHasPrefix,omitempty"`
	UserHasSuffix    *string  `json:"userHasSuffix,omitempty"`
	UserEqualFold    *string  `json:"userEqualFold,omitempty"`
	UserContainsFold *string  `json:"userContainsFold,omitempty"`

	// "action" field predicates.
	Action             *string  `json:"action,omitempty"`
	ActionNEQ          *string  `json:"actionNEQ,omitempty"`
	ActionIn           []string `json:"actionIn,omitempty"`
	ActionNotIn        []string `json:"actionNotIn,omitempty"`
	ActionGT           *string  `json:"actionGT,omitempty"`
	ActionGTE          *string  `json:"actionGTE,omitempty"`
	ActionLT           *string  `json:"actionLT,omitempty"`
	ActionLTE          *string  `json:"actionLTE,omitempty"`
	ActionContains     *string  `json:"actionContains,omitempty"`
	ActionHasPrefix    *string  `json:"actionHasPrefix,omitempty"`
	ActionHasSuffix    *string  `json:"actionHasSuffix,omitempty"`
	ActionEqualFold    *string  `json:"actionEqualFold,omitempty"`
	ActionContainsFold *string  `json:"actionContainsFold,omitempty"`

	// "entity_schema" field predicates.
	EntitySchema             *string  `json:"entitySchema,omitempty"`
	EntitySchemaNEQ          *string  `json:"entitySchemaNEQ,omitempty"`
	EntitySchemaIn           []string `json:"entitySchemaIn,omitempty"`
	EntitySchemaNotIn        []string `json:"entitySchemaNotIn,omitempty"`
	EntitySchemaGT           *string  `json:"entitySchemaGT,omitempty"`
	EntitySchemaGTE          *string  `json:"entitySchemaGTE,omitempty"`
	EntitySchemaLT           *string  `json:"entitySchemaLT,omitempty"`
	EntitySchemaLTE          *string  `json:"entitySchemaLTE,omitempty"`
	EntitySchemaContains     *string  `json:"entitySchemaContains,omitempty"`
	EntitySchemaHasPrefix    *string  `json:"entitySchemaHasPrefix,omitempty"`
	EntitySchemaHasSuffix    *string  `json:"entitySchemaHasSuffix,omitempty"`
	EntitySchemaEqualFold    *string  `json:"entitySchemaEqualFold,omitempty"`
	EntitySchemaContainsFold *string  `json:"entitySchemaContainsFold,omitempty"`

	// "entity_uuid" field predicates.
	EntityUUID             *string  `json:"entityUUID,omitempty"`
	EntityUUIDNEQ          *string  `json:"entityUUIDNEQ,omitempty"`
	EntityUUIDIn           []string `json:"entityUUIDIn,omitempty"`
	EntityUUIDNotIn        []string `json:"entityUUIDNotIn,omitempty"`
	EntityUUIDGT           *string  `json:"entityUUIDGT,omitempty"`
	EntityUUIDGTE          *string  `json:"entityUUIDGTE,omitempty"`
	EntityUUIDLT           *string  `json:"entityUUIDLT,omitempty"`
	EntityUUIDLTE          *string  `json:"entityUUIDLTE,omitempty"`
	EntityUUIDContains     *string  `json:"entityUUIDContains,omitempty"`
	EntityUUIDHasPrefix    *string  `json:"entityUUIDHasPrefix,omitempty"`
	EntityUUIDHasSuffix    *string  `json:"entityUUIDHasSuffix,omitempty"`
	EntityUUIDIsNil        bool     `json:"entityUUIDIsNil,omitempty"`
	EntityUUIDNotNil       bool     `json:"entityUUIDNotNil,omitempty"`
	EntityUUIDEqualFold    *string  `json:"entityUUIDEqualFold,omitempty"`
	EntityUUIDContainsFold *string  `json:"entityUUIDContainsFold,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuditLogWhereInput) AddPredicates(predicates ...predicate.AuditLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuditLogWhereInput filter on the AuditLogQuery builder.
func (i *AuditLogWhereInput) Filter(q *AuditLogQuery) (*AuditLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuditLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuditLogWhereInput is returned in case the AuditLogWhereInput is empty.
var ErrEmptyAuditLogWhereInput = errors.New("ent: empty predicate AuditLogWhereInput")

// P returns a predicate for filtering auditlogs.
// An error is returned if the input is empty or invalid.
func (i *AuditLogWhereInput) P() (predicate.AuditLog, error) {
	var predicates []predicate.AuditLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, auditlog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AuditLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, auditlog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AuditLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, auditlog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, auditlog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, auditlog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, auditlog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, auditlog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, auditlog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, auditlog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, auditlog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, auditlog.IDLTE(*i.IDLTE))
	}
	if i.User != nil {
		predicates = append(predicates, auditlog.UserEQ(*i.User))
	}
	if i.UserNEQ != nil {
		predicates = append(predicates, auditlog.UserNEQ(*i.UserNEQ))
	}
	if len(i.UserIn) > 0 {
		predicates = append(predicates, auditlog.UserIn(i.UserIn...))
	}
	if len(i.UserNotIn) > 0 {
		predicates = append(predicates, auditlog.UserNotIn(i.UserNotIn...))
	}
	if i.UserGT != nil {
		predicates = append(predicates, auditlog.UserGT(*i.UserGT))
	}
	if i.UserGTE != nil {
		predicates = append(predicates, auditlog.UserGTE(*i.UserGTE))
	}
	if i.UserLT != nil {
		predicates = append(predicates, auditlog.UserLT(*i.UserLT))
	}
	if i.UserLTE != nil {
		predicates = append(predicates, auditlog.UserLTE(*i.UserLTE))
	}
	if i.UserContains != nil {
		predicates = append(predicates, auditlog.UserContains(*i.UserContains))
	}
	if i.UserHasPrefix != nil {
		predicates = append(predicates, auditlog.UserHasPrefix(*i.UserHasPrefix))
	}
	if i.UserHasSuffix != nil {
		predicates = append(predicates, auditlog.UserHasSuffix(*i.UserHasSuffix))
	}
	if i.UserEqualFold != nil {
		predicates = append(predicates, auditlog.UserEqualFold(*i.UserEqualFold))
	}
	if i.UserContainsFold != nil {
		predicates = append(predicates, auditlog.UserContainsFold(*i.UserContainsFold))
	}
	if i.Action != nil {
		predicates = append(predicates, auditlog.ActionEQ(*i.Action))
	}
	if i.ActionNEQ != nil {
		predicates = append(predicates, auditlog.ActionNEQ(*i.ActionNEQ))
	}
	if len(i.ActionIn) > 0 {
		predicates = append(predicates, auditlog.ActionIn(i.ActionIn...))
	}
	if len(i.ActionNotIn) > 0 {
		predicates = append(predicates, auditlog.ActionNotIn(i.ActionNotIn...))
	}
	if i.ActionGT != nil {
		predicates = append(predicates, auditlog.ActionGT(*i.ActionGT))
	}
	if i.ActionGTE != nil {
		predicates = append(predicates, auditlog.ActionGTE(*i.ActionGTE))
	}
	if i.ActionLT != nil {
		predicates = append(predicates, auditlog.ActionLT(*i.ActionLT))
	}
	if i.ActionLTE != nil {
		predicates = append(predicates, auditlog.ActionLTE(*i.ActionLTE))
	}
	if i.ActionContains != nil {
		predicates = append(predicates, auditlog.ActionContains(*i.ActionContains))
	}
	if i.ActionHasPrefix != nil {
		predicates = append(predicates, auditlog.ActionHasPrefix(*i.ActionHasPrefix))
	}
	if i.ActionHasSuffix != nil {
		predicates = append(predicates, auditlog.ActionHasSuffix(*i.ActionHasSuffix))
	}
	if i.ActionEqualFold != nil {
		predicates = append(predicates, auditlog.ActionEqualFold(*i.ActionEqualFold))
	}
	if i.ActionContainsFold != nil {
		predicates = append(predicates, auditlog.ActionContainsFold(*i.ActionContainsFold))
	}
	if i.EntitySchema != nil {
		predicates = append(predicates, auditlog.EntitySchemaEQ(*i.EntitySchema))
	}
	if i.EntitySchemaNEQ != nil {
		predicates = append(predicates, auditlog.EntitySchemaNEQ(*i.EntitySchemaNEQ))
	}
	if len(i.EntitySchemaIn) > 0 {
		predicates = append(predicates, auditlog.EntitySchemaIn(i.EntitySchemaIn...))
	}
	if len(i.EntitySchemaNotIn) > 0 {
		predicates = append(predicates, auditlog.EntitySchemaNotIn(i.EntitySchemaNotIn...))
	}
	if i.EntitySchemaGT != nil {
		predicates = append(predicates, auditlog.EntitySchemaGT(*i.EntitySchemaGT))
	}
	if i.EntitySchemaGTE != nil {
		predicates = append(predicates, auditlog.EntitySchemaGTE(*i.EntitySchemaGTE))
	}
	if i.EntitySchemaLT != nil {
		predicates = append(predicates, auditlog.EntitySchemaLT(*i.EntitySchemaLT))
	}
	if i.EntitySchemaLTE != nil {
		predicates = append(predicates, auditlog.EntitySchemaLTE(*i.EntitySchemaLTE))
	}
	if i.EntitySchemaContains != nil {
		predicates = append(predicates, auditlog.EntitySchemaContains(*i.EntitySchemaContains))
	}
	if i.EntitySchemaHasPrefix != nil {
		predicates = append(predicates, auditlog.EntitySchemaHasPrefix(*i.EntitySchemaHasPrefix))
	}
	if i.EntitySchemaHasSuffix != nil {
		predicates = append(predicates, auditlog.EntitySchemaHasSuffix(*i.EntitySchemaHasSuffix))
	}
	if i.EntitySchemaEqualFold != nil {
		predicates = append(predicates, auditlog.EntitySchemaEqualFold(*i.EntitySchemaEqualFold))
	}
	if i.EntitySchemaContainsFold != nil {
		predicates = append(predicates, auditlog.EntitySchemaContainsFold(*i.EntitySchemaContainsFold))
	}
	if i.EntityUUID != nil {
		predicates = append(predicates, auditlog.EntityUUIDEQ(*i.EntityUUID))
	}
	if i.EntityUUIDNEQ != nil {
		predicates = append(predicates, auditlog.EntityUUIDNEQ(*i.EntityUUIDNEQ))
	}
	if len(i.EntityUUIDIn) > 0 {
		predicates = append(predicates, auditlog.EntityUUIDIn(i.EntityUUIDIn...))
	}
	if len(i.EntityUUIDNotIn) > 0 {
		predicates = append(predicates, auditlog.EntityUUIDNotIn(i.EntityUUIDNotIn...))
	}
	if i.EntityUUIDGT != nil {
		predicates = append(predicates, auditlog.EntityUUIDGT(*i.EntityUUIDGT))
	}
	if i.EntityUUIDGTE != nil {
		predicates = append(predicates, auditlog.EntityUUIDGTE(*i.EntityUUIDGTE))
	}
	if i.EntityUUIDLT != nil {
		predicates = append(predicates, auditlog.EntityUUIDLT(*i.EntityUUIDLT))
	}
	if i.EntityUUIDLTE != nil {
		predicates = append(predicates, auditlog.EntityUUIDLTE(*i.EntityUUIDLTE))
	}
	if i.EntityUUIDContains != nil {
		predicates = append(predicates, auditlog.EntityUUIDContains(*i.EntityUUIDContains))
	}
	if i.EntityUUIDHasPrefix != nil {
		predicates = append(predicates, auditlog.EntityUUIDHasPrefix(*i.EntityUUIDHasPrefix))
	}
	if i.EntityUUIDHasSuffix != nil {
		predicates = append(predicates, auditlog.EntityUUIDHasSuffix(*i.EntityUUIDHasSuffix))
	}
	if i.EntityUUIDIsNil {
		predicates = append(predicates, auditlog.EntityUUIDIsNil())
	}
	if i.EntityUUIDNotNil {
		predicates = append(predicates, auditlog.EntityUUIDNotNil())
	}
	if i.EntityUUIDEqualFold != nil {
		predicates = append(predicates, auditlog.EntityUUIDEqualFold(*i.EntityUUIDEqualFold))
	}
	if i.EntityUUIDContainsFold != nil {
		predicates = append(predicates, auditlog.EntityUUIDContainsFold(*i.EntityUUIDContainsFold))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, auditlog.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, auditlog.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, auditlog.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, auditlog.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, auditlog.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, auditlog.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, auditlog.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, auditlog.TimestampLTE(*i.TimestampLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuditLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return auditlog.And(predicates...), nil
	}
}

// BusinessWhereInput represents a where input for filtering Business queries.
type BusinessWhereInput struct {
	Predicates []predicate.Business  `json:"-"`
	Not        *BusinessWhereInput   `json:"not,omitempty"`
	Or         []*BusinessWhereInput `json:"or,omitempty"`
	And        []*BusinessWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name1" field predicates.
	Name1             *string  `json:"name1,omitempty"`
	Name1NEQ          *string  `json:"name1NEQ,omitempty"`
	Name1In           []string `json:"name1In,omitempty"`
	Name1NotIn        []string `json:"name1NotIn,omitempty"`
	Name1GT           *string  `json:"name1GT,omitempty"`
	Name1GTE          *string  `json:"name1GTE,omitempty"`
	Name1LT           *string  `json:"name1LT,omitempty"`
	Name1LTE          *string  `json:"name1LTE,omitempty"`
	Name1Contains     *string  `json:"name1Contains,omitempty"`
	Name1HasPrefix    *string  `json:"name1HasPrefix,omitempty"`
	Name1HasSuffix    *string  `json:"name1HasSuffix,omitempty"`
	Name1EqualFold    *string  `json:"name1EqualFold,omitempty"`
	Name1ContainsFold *string  `json:"name1ContainsFold,omitempty"`

	// "name2" field predicates.
	Name2             *string  `json:"name2,omitempty"`
	Name2NEQ          *string  `json:"name2NEQ,omitempty"`
	Name2In           []string `json:"name2In,omitempty"`
	Name2NotIn        []string `json:"name2NotIn,omitempty"`
	Name2GT           *string  `json:"name2GT,omitempty"`
	Name2GTE          *string  `json:"name2GTE,omitempty"`
	Name2LT           *string  `json:"name2LT,omitempty"`
	Name2LTE          *string  `json:"name2LTE,omitempty"`
	Name2Contains     *string  `json:"name2Contains,omitempty"`
	Name2HasPrefix    *string  `json:"name2HasPrefix,omitempty"`
	Name2HasSuffix    *string  `json:"name2HasSuffix,omitempty"`
	Name2IsNil        bool     `json:"name2IsNil,omitempty"`
	Name2NotNil       bool     `json:"name2NotNil,omitempty"`
	Name2EqualFold    *string  `json:"name2EqualFold,omitempty"`
	Name2ContainsFold *string  `json:"name2ContainsFold,omitempty"`

	// "alias" field predicates.
	Alias             *string  `json:"alias,omitempty"`
	AliasNEQ          *string  `json:"aliasNEQ,omitempty"`
	AliasIn           []string `json:"aliasIn,omitempty"`
	AliasNotIn        []string `json:"aliasNotIn,omitempty"`
	AliasGT           *string  `json:"aliasGT,omitempty"`
	AliasGTE          *string  `json:"aliasGTE,omitempty"`
	AliasLT           *string  `json:"aliasLT,omitempty"`
	AliasLTE          *string  `json:"aliasLTE,omitempty"`
	AliasContains     *string  `json:"aliasContains,omitempty"`
	AliasHasPrefix    *string  `json:"aliasHasPrefix,omitempty"`
	AliasHasSuffix    *string  `json:"aliasHasSuffix,omitempty"`
	AliasEqualFold    *string  `json:"aliasEqualFold,omitempty"`
	AliasContainsFold *string  `json:"aliasContainsFold,omitempty"`

	// "telephone" field predicates.
	Telephone             *string  `json:"telephone,omitempty"`
	TelephoneNEQ          *string  `json:"telephoneNEQ,omitempty"`
	TelephoneIn           []string `json:"telephoneIn,omitempty"`
	TelephoneNotIn        []string `json:"telephoneNotIn,omitempty"`
	TelephoneGT           *string  `json:"telephoneGT,omitempty"`
	TelephoneGTE          *string  `json:"telephoneGTE,omitempty"`
	TelephoneLT           *string  `json:"telephoneLT,omitempty"`
	TelephoneLTE          *string  `json:"telephoneLTE,omitempty"`
	TelephoneContains     *string  `json:"telephoneContains,omitempty"`
	TelephoneHasPrefix    *string  `json:"telephoneHasPrefix,omitempty"`
	TelephoneHasSuffix    *string  `json:"telephoneHasSuffix,omitempty"`
	TelephoneIsNil        bool     `json:"telephoneIsNil,omitempty"`
	TelephoneNotNil       bool     `json:"telephoneNotNil,omitempty"`
	TelephoneEqualFold    *string  `json:"telephoneEqualFold,omitempty"`
	TelephoneContainsFold *string  `json:"telephoneContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "website" field predicates.
	Website             *string  `json:"website,omitempty"`
	WebsiteNEQ          *string  `json:"websiteNEQ,omitempty"`
	WebsiteIn           []string `json:"websiteIn,omitempty"`
	WebsiteNotIn        []string `json:"websiteNotIn,omitempty"`
	WebsiteGT           *string  `json:"websiteGT,omitempty"`
	WebsiteGTE          *string  `json:"websiteGTE,omitempty"`
	WebsiteLT           *string  `json:"websiteLT,omitempty"`
	WebsiteLTE          *string  `json:"websiteLTE,omitempty"`
	WebsiteContains     *string  `json:"websiteContains,omitempty"`
	WebsiteHasPrefix    *string  `json:"websiteHasPrefix,omitempty"`
	WebsiteHasSuffix    *string  `json:"websiteHasSuffix,omitempty"`
	WebsiteIsNil        bool     `json:"websiteIsNil,omitempty"`
	WebsiteNotNil       bool     `json:"websiteNotNil,omitempty"`
	WebsiteEqualFold    *string  `json:"websiteEqualFold,omitempty"`
	WebsiteContainsFold *string  `json:"websiteContainsFold,omitempty"`

	// "comment" field predicates.
	Comment             *string  `json:"comment,omitempty"`
	CommentNEQ          *string  `json:"commentNEQ,omitempty"`
	CommentIn           []string `json:"commentIn,omitempty"`
	CommentNotIn        []string `json:"commentNotIn,omitempty"`
	CommentGT           *string  `json:"commentGT,omitempty"`
	CommentGTE          *string  `json:"commentGTE,omitempty"`
	CommentLT           *string  `json:"commentLT,omitempty"`
	CommentLTE          *string  `json:"commentLTE,omitempty"`
	CommentContains     *string  `json:"commentContains,omitempty"`
	CommentHasPrefix    *string  `json:"commentHasPrefix,omitempty"`
	CommentHasSuffix    *string  `json:"commentHasSuffix,omitempty"`
	CommentIsNil        bool     `json:"commentIsNil,omitempty"`
	CommentNotNil       bool     `json:"commentNotNil,omitempty"`
	CommentEqualFold    *string  `json:"commentEqualFold,omitempty"`
	CommentContainsFold *string  `json:"commentContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "addresses" edge predicates.
	HasAddresses     *bool                `json:"hasAddresses,omitempty"`
	HasAddressesWith []*AddressWhereInput `json:"hasAddressesWith,omitempty"`

	// "tags" edge predicates.
	HasTags     *bool            `json:"hasTags,omitempty"`
	HasTagsWith []*TagWhereInput `json:"hasTagsWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BusinessWhereInput) AddPredicates(predicates ...predicate.Business) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BusinessWhereInput filter on the BusinessQuery builder.
func (i *BusinessWhereInput) Filter(q *BusinessQuery) (*BusinessQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBusinessWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBusinessWhereInput is returned in case the BusinessWhereInput is empty.
var ErrEmptyBusinessWhereInput = errors.New("ent: empty predicate BusinessWhereInput")

// P returns a predicate for filtering businesses.
// An error is returned if the input is empty or invalid.
func (i *BusinessWhereInput) P() (predicate.Business, error) {
	var predicates []predicate.Business
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, business.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Business, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, business.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Business, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, business.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, business.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, business.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, business.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, business.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, business.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, business.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, business.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, business.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, business.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, business.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, business.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, business.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, business.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, business.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, business.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, business.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, business.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, business.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, business.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, business.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, business.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, business.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, business.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, business.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, business.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, business.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, business.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, business.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, business.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, business.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, business.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, business.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, business.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, business.DeletedAtNotNil())
	}
	if i.Name1 != nil {
		predicates = append(predicates, business.Name1EQ(*i.Name1))
	}
	if i.Name1NEQ != nil {
		predicates = append(predicates, business.Name1NEQ(*i.Name1NEQ))
	}
	if len(i.Name1In) > 0 {
		predicates = append(predicates, business.Name1In(i.Name1In...))
	}
	if len(i.Name1NotIn) > 0 {
		predicates = append(predicates, business.Name1NotIn(i.Name1NotIn...))
	}
	if i.Name1GT != nil {
		predicates = append(predicates, business.Name1GT(*i.Name1GT))
	}
	if i.Name1GTE != nil {
		predicates = append(predicates, business.Name1GTE(*i.Name1GTE))
	}
	if i.Name1LT != nil {
		predicates = append(predicates, business.Name1LT(*i.Name1LT))
	}
	if i.Name1LTE != nil {
		predicates = append(predicates, business.Name1LTE(*i.Name1LTE))
	}
	if i.Name1Contains != nil {
		predicates = append(predicates, business.Name1Contains(*i.Name1Contains))
	}
	if i.Name1HasPrefix != nil {
		predicates = append(predicates, business.Name1HasPrefix(*i.Name1HasPrefix))
	}
	if i.Name1HasSuffix != nil {
		predicates = append(predicates, business.Name1HasSuffix(*i.Name1HasSuffix))
	}
	if i.Name1EqualFold != nil {
		predicates = append(predicates, business.Name1EqualFold(*i.Name1EqualFold))
	}
	if i.Name1ContainsFold != nil {
		predicates = append(predicates, business.Name1ContainsFold(*i.Name1ContainsFold))
	}
	if i.Name2 != nil {
		predicates = append(predicates, business.Name2EQ(*i.Name2))
	}
	if i.Name2NEQ != nil {
		predicates = append(predicates, business.Name2NEQ(*i.Name2NEQ))
	}
	if len(i.Name2In) > 0 {
		predicates = append(predicates, business.Name2In(i.Name2In...))
	}
	if len(i.Name2NotIn) > 0 {
		predicates = append(predicates, business.Name2NotIn(i.Name2NotIn...))
	}
	if i.Name2GT != nil {
		predicates = append(predicates, business.Name2GT(*i.Name2GT))
	}
	if i.Name2GTE != nil {
		predicates = append(predicates, business.Name2GTE(*i.Name2GTE))
	}
	if i.Name2LT != nil {
		predicates = append(predicates, business.Name2LT(*i.Name2LT))
	}
	if i.Name2LTE != nil {
		predicates = append(predicates, business.Name2LTE(*i.Name2LTE))
	}
	if i.Name2Contains != nil {
		predicates = append(predicates, business.Name2Contains(*i.Name2Contains))
	}
	if i.Name2HasPrefix != nil {
		predicates = append(predicates, business.Name2HasPrefix(*i.Name2HasPrefix))
	}
	if i.Name2HasSuffix != nil {
		predicates = append(predicates, business.Name2HasSuffix(*i.Name2HasSuffix))
	}
	if i.Name2IsNil {
		predicates = append(predicates, business.Name2IsNil())
	}
	if i.Name2NotNil {
		predicates = append(predicates, business.Name2NotNil())
	}
	if i.Name2EqualFold != nil {
		predicates = append(predicates, business.Name2EqualFold(*i.Name2EqualFold))
	}
	if i.Name2ContainsFold != nil {
		predicates = append(predicates, business.Name2ContainsFold(*i.Name2ContainsFold))
	}
	if i.Alias != nil {
		predicates = append(predicates, business.AliasEQ(*i.Alias))
	}
	if i.AliasNEQ != nil {
		predicates = append(predicates, business.AliasNEQ(*i.AliasNEQ))
	}
	if len(i.AliasIn) > 0 {
		predicates = append(predicates, business.AliasIn(i.AliasIn...))
	}
	if len(i.AliasNotIn) > 0 {
		predicates = append(predicates, business.AliasNotIn(i.AliasNotIn...))
	}
	if i.AliasGT != nil {
		predicates = append(predicates, business.AliasGT(*i.AliasGT))
	}
	if i.AliasGTE != nil {
		predicates = append(predicates, business.AliasGTE(*i.AliasGTE))
	}
	if i.AliasLT != nil {
		predicates = append(predicates, business.AliasLT(*i.AliasLT))
	}
	if i.AliasLTE != nil {
		predicates = append(predicates, business.AliasLTE(*i.AliasLTE))
	}
	if i.AliasContains != nil {
		predicates = append(predicates, business.AliasContains(*i.AliasContains))
	}
	if i.AliasHasPrefix != nil {
		predicates = append(predicates, business.AliasHasPrefix(*i.AliasHasPrefix))
	}
	if i.AliasHasSuffix != nil {
		predicates = append(predicates, business.AliasHasSuffix(*i.AliasHasSuffix))
	}
	if i.AliasEqualFold != nil {
		predicates = append(predicates, business.AliasEqualFold(*i.AliasEqualFold))
	}
	if i.AliasContainsFold != nil {
		predicates = append(predicates, business.AliasContainsFold(*i.AliasContainsFold))
	}
	if i.Telephone != nil {
		predicates = append(predicates, business.TelephoneEQ(*i.Telephone))
	}
	if i.TelephoneNEQ != nil {
		predicates = append(predicates, business.TelephoneNEQ(*i.TelephoneNEQ))
	}
	if len(i.TelephoneIn) > 0 {
		predicates = append(predicates, business.TelephoneIn(i.TelephoneIn...))
	}
	if len(i.TelephoneNotIn) > 0 {
		predicates = append(predicates, business.TelephoneNotIn(i.TelephoneNotIn...))
	}
	if i.TelephoneGT != nil {
		predicates = append(predicates, business.TelephoneGT(*i.TelephoneGT))
	}
	if i.TelephoneGTE != nil {
		predicates = append(predicates, business.TelephoneGTE(*i.TelephoneGTE))
	}
	if i.TelephoneLT != nil {
		predicates = append(predicates, business.TelephoneLT(*i.TelephoneLT))
	}
	if i.TelephoneLTE != nil {
		predicates = append(predicates, business.TelephoneLTE(*i.TelephoneLTE))
	}
	if i.TelephoneContains != nil {
		predicates = append(predicates, business.TelephoneContains(*i.TelephoneContains))
	}
	if i.TelephoneHasPrefix != nil {
		predicates = append(predicates, business.TelephoneHasPrefix(*i.TelephoneHasPrefix))
	}
	if i.TelephoneHasSuffix != nil {
		predicates = append(predicates, business.TelephoneHasSuffix(*i.TelephoneHasSuffix))
	}
	if i.TelephoneIsNil {
		predicates = append(predicates, business.TelephoneIsNil())
	}
	if i.TelephoneNotNil {
		predicates = append(predicates, business.TelephoneNotNil())
	}
	if i.TelephoneEqualFold != nil {
		predicates = append(predicates, business.TelephoneEqualFold(*i.TelephoneEqualFold))
	}
	if i.TelephoneContainsFold != nil {
		predicates = append(predicates, business.TelephoneContainsFold(*i.TelephoneContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, business.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, business.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, business.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, business.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, business.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, business.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, business.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, business.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, business.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, business.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, business.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, business.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, business.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, business.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, business.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Website != nil {
		predicates = append(predicates, business.WebsiteEQ(*i.Website))
	}
	if i.WebsiteNEQ != nil {
		predicates = append(predicates, business.WebsiteNEQ(*i.WebsiteNEQ))
	}
	if len(i.WebsiteIn) > 0 {
		predicates = append(predicates, business.WebsiteIn(i.WebsiteIn...))
	}
	if len(i.WebsiteNotIn) > 0 {
		predicates = append(predicates, business.WebsiteNotIn(i.WebsiteNotIn...))
	}
	if i.WebsiteGT != nil {
		predicates = append(predicates, business.WebsiteGT(*i.WebsiteGT))
	}
	if i.WebsiteGTE != nil {
		predicates = append(predicates, business.WebsiteGTE(*i.WebsiteGTE))
	}
	if i.WebsiteLT != nil {
		predicates = append(predicates, business.WebsiteLT(*i.WebsiteLT))
	}
	if i.WebsiteLTE != nil {
		predicates = append(predicates, business.WebsiteLTE(*i.WebsiteLTE))
	}
	if i.WebsiteContains != nil {
		predicates = append(predicates, business.WebsiteContains(*i.WebsiteContains))
	}
	if i.WebsiteHasPrefix != nil {
		predicates = append(predicates, business.WebsiteHasPrefix(*i.WebsiteHasPrefix))
	}
	if i.WebsiteHasSuffix != nil {
		predicates = append(predicates, business.WebsiteHasSuffix(*i.WebsiteHasSuffix))
	}
	if i.WebsiteIsNil {
		predicates = append(predicates, business.WebsiteIsNil())
	}
	if i.WebsiteNotNil {
		predicates = append(predicates, business.WebsiteNotNil())
	}
	if i.WebsiteEqualFold != nil {
		predicates = append(predicates, business.WebsiteEqualFold(*i.WebsiteEqualFold))
	}
	if i.WebsiteContainsFold != nil {
		predicates = append(predicates, business.WebsiteContainsFold(*i.WebsiteContainsFold))
	}
	if i.Comment != nil {
		predicates = append(predicates, business.CommentEQ(*i.Comment))
	}
	if i.CommentNEQ != nil {
		predicates = append(predicates, business.CommentNEQ(*i.CommentNEQ))
	}
	if len(i.CommentIn) > 0 {
		predicates = append(predicates, business.CommentIn(i.CommentIn...))
	}
	if len(i.CommentNotIn) > 0 {
		predicates = append(predicates, business.CommentNotIn(i.CommentNotIn...))
	}
	if i.CommentGT != nil {
		predicates = append(predicates, business.CommentGT(*i.CommentGT))
	}
	if i.CommentGTE != nil {
		predicates = append(predicates, business.CommentGTE(*i.CommentGTE))
	}
	if i.CommentLT != nil {
		predicates = append(predicates, business.CommentLT(*i.CommentLT))
	}
	if i.CommentLTE != nil {
		predicates = append(predicates, business.CommentLTE(*i.CommentLTE))
	}
	if i.CommentContains != nil {
		predicates = append(predicates, business.CommentContains(*i.CommentContains))
	}
	if i.CommentHasPrefix != nil {
		predicates = append(predicates, business.CommentHasPrefix(*i.CommentHasPrefix))
	}
	if i.CommentHasSuffix != nil {
		predicates = append(predicates, business.CommentHasSuffix(*i.CommentHasSuffix))
	}
	if i.CommentIsNil {
		predicates = append(predicates, business.CommentIsNil())
	}
	if i.CommentNotNil {
		predicates = append(predicates, business.CommentNotNil())
	}
	if i.CommentEqualFold != nil {
		predicates = append(predicates, business.CommentEqualFold(*i.CommentEqualFold))
	}
	if i.CommentContainsFold != nil {
		predicates = append(predicates, business.CommentContainsFold(*i.CommentContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, business.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, business.ActiveNEQ(*i.ActiveNEQ))
	}

	if i.HasAddresses != nil {
		p := business.HasAddresses()
		if !*i.HasAddresses {
			p = business.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAddressesWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasAddressesWith))
		for _, w := range i.HasAddressesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAddressesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, business.HasAddressesWith(with...))
	}
	if i.HasTags != nil {
		p := business.HasTags()
		if !*i.HasTags {
			p = business.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTagsWith) > 0 {
		with := make([]predicate.Tag, 0, len(i.HasTagsWith))
		for _, w := range i.HasTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, business.HasTagsWith(with...))
	}
	if i.HasUsers != nil {
		p := business.HasUsers()
		if !*i.HasUsers {
			p = business.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, business.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBusinessWhereInput
	case 1:
		return predicates[0], nil
	default:
		return business.And(predicates...), nil
	}
}

// ContentWhereInput represents a where input for filtering Content queries.
type ContentWhereInput struct {
	Predicates []predicate.Content  `json:"-"`
	Not        *ContentWhereInput   `json:"not,omitempty"`
	Or         []*ContentWhereInput `json:"or,omitempty"`
	And        []*ContentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "timetable_type" field predicates.
	TimetableType      *content.TimetableType  `json:"timetableType,omitempty"`
	TimetableTypeNEQ   *content.TimetableType  `json:"timetableTypeNEQ,omitempty"`
	TimetableTypeIn    []content.TimetableType `json:"timetableTypeIn,omitempty"`
	TimetableTypeNotIn []content.TimetableType `json:"timetableTypeNotIn,omitempty"`

	// "type" field predicates.
	Type      *content.Type  `json:"type,omitempty"`
	TypeNEQ   *content.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []content.Type `json:"typeIn,omitempty"`
	TypeNotIn []content.Type `json:"typeNotIn,omitempty"`

	// "locale" field predicates.
	Locale             *string  `json:"locale,omitempty"`
	LocaleNEQ          *string  `json:"localeNEQ,omitempty"`
	LocaleIn           []string `json:"localeIn,omitempty"`
	LocaleNotIn        []string `json:"localeNotIn,omitempty"`
	LocaleGT           *string  `json:"localeGT,omitempty"`
	LocaleGTE          *string  `json:"localeGTE,omitempty"`
	LocaleLT           *string  `json:"localeLT,omitempty"`
	LocaleLTE          *string  `json:"localeLTE,omitempty"`
	LocaleContains     *string  `json:"localeContains,omitempty"`
	LocaleHasPrefix    *string  `json:"localeHasPrefix,omitempty"`
	LocaleHasSuffix    *string  `json:"localeHasSuffix,omitempty"`
	LocaleEqualFold    *string  `json:"localeEqualFold,omitempty"`
	LocaleContainsFold *string  `json:"localeContainsFold,omitempty"`

	// "location" field predicates.
	Location      *content.Location  `json:"location,omitempty"`
	LocationNEQ   *content.Location  `json:"locationNEQ,omitempty"`
	LocationIn    []content.Location `json:"locationIn,omitempty"`
	LocationNotIn []content.Location `json:"locationNotIn,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "status" field predicates.
	Status      *content.Status  `json:"status,omitempty"`
	StatusNEQ   *content.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []content.Status `json:"statusIn,omitempty"`
	StatusNotIn []content.Status `json:"statusNotIn,omitempty"`

	// "published_at" field predicates.
	PublishedAt       *time.Time  `json:"publishedAt,omitempty"`
	PublishedAtNEQ    *time.Time  `json:"publishedAtNEQ,omitempty"`
	PublishedAtIn     []time.Time `json:"publishedAtIn,omitempty"`
	PublishedAtNotIn  []time.Time `json:"publishedAtNotIn,omitempty"`
	PublishedAtGT     *time.Time  `json:"publishedAtGT,omitempty"`
	PublishedAtGTE    *time.Time  `json:"publishedAtGTE,omitempty"`
	PublishedAtLT     *time.Time  `json:"publishedAtLT,omitempty"`
	PublishedAtLTE    *time.Time  `json:"publishedAtLTE,omitempty"`
	PublishedAtIsNil  bool        `json:"publishedAtIsNil,omitempty"`
	PublishedAtNotNil bool        `json:"publishedAtNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContentWhereInput) AddPredicates(predicates ...predicate.Content) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContentWhereInput filter on the ContentQuery builder.
func (i *ContentWhereInput) Filter(q *ContentQuery) (*ContentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContentWhereInput is returned in case the ContentWhereInput is empty.
var ErrEmptyContentWhereInput = errors.New("ent: empty predicate ContentWhereInput")

// P returns a predicate for filtering contents.
// An error is returned if the input is empty or invalid.
func (i *ContentWhereInput) P() (predicate.Content, error) {
	var predicates []predicate.Content
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, content.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Content, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, content.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Content, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, content.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, content.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, content.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, content.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, content.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, content.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, content.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, content.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, content.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, content.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, content.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, content.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, content.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, content.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, content.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, content.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, content.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, content.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, content.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, content.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, content.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, content.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, content.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, content.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, content.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, content.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, content.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, content.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, content.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, content.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, content.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, content.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, content.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, content.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, content.DeletedAtNotNil())
	}
	if i.TimetableType != nil {
		predicates = append(predicates, content.TimetableTypeEQ(*i.TimetableType))
	}
	if i.TimetableTypeNEQ != nil {
		predicates = append(predicates, content.TimetableTypeNEQ(*i.TimetableTypeNEQ))
	}
	if len(i.TimetableTypeIn) > 0 {
		predicates = append(predicates, content.TimetableTypeIn(i.TimetableTypeIn...))
	}
	if len(i.TimetableTypeNotIn) > 0 {
		predicates = append(predicates, content.TimetableTypeNotIn(i.TimetableTypeNotIn...))
	}
	if i.Type != nil {
		predicates = append(predicates, content.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, content.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, content.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, content.TypeNotIn(i.TypeNotIn...))
	}
	if i.Locale != nil {
		predicates = append(predicates, content.LocaleEQ(*i.Locale))
	}
	if i.LocaleNEQ != nil {
		predicates = append(predicates, content.LocaleNEQ(*i.LocaleNEQ))
	}
	if len(i.LocaleIn) > 0 {
		predicates = append(predicates, content.LocaleIn(i.LocaleIn...))
	}
	if len(i.LocaleNotIn) > 0 {
		predicates = append(predicates, content.LocaleNotIn(i.LocaleNotIn...))
	}
	if i.LocaleGT != nil {
		predicates = append(predicates, content.LocaleGT(*i.LocaleGT))
	}
	if i.LocaleGTE != nil {
		predicates = append(predicates, content.LocaleGTE(*i.LocaleGTE))
	}
	if i.LocaleLT != nil {
		predicates = append(predicates, content.LocaleLT(*i.LocaleLT))
	}
	if i.LocaleLTE != nil {
		predicates = append(predicates, content.LocaleLTE(*i.LocaleLTE))
	}
	if i.LocaleContains != nil {
		predicates = append(predicates, content.LocaleContains(*i.LocaleContains))
	}
	if i.LocaleHasPrefix != nil {
		predicates = append(predicates, content.LocaleHasPrefix(*i.LocaleHasPrefix))
	}
	if i.LocaleHasSuffix != nil {
		predicates = append(predicates, content.LocaleHasSuffix(*i.LocaleHasSuffix))
	}
	if i.LocaleEqualFold != nil {
		predicates = append(predicates, content.LocaleEqualFold(*i.LocaleEqualFold))
	}
	if i.LocaleContainsFold != nil {
		predicates = append(predicates, content.LocaleContainsFold(*i.LocaleContainsFold))
	}
	if i.Location != nil {
		predicates = append(predicates, content.LocationEQ(*i.Location))
	}
	if i.LocationNEQ != nil {
		predicates = append(predicates, content.LocationNEQ(*i.LocationNEQ))
	}
	if len(i.LocationIn) > 0 {
		predicates = append(predicates, content.LocationIn(i.LocationIn...))
	}
	if len(i.LocationNotIn) > 0 {
		predicates = append(predicates, content.LocationNotIn(i.LocationNotIn...))
	}
	if i.Content != nil {
		predicates = append(predicates, content.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, content.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, content.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, content.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, content.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, content.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, content.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, content.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, content.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, content.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, content.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, content.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, content.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, content.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, content.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, content.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, content.StatusNotIn(i.StatusNotIn...))
	}
	if i.PublishedAt != nil {
		predicates = append(predicates, content.PublishedAtEQ(*i.PublishedAt))
	}
	if i.PublishedAtNEQ != nil {
		predicates = append(predicates, content.PublishedAtNEQ(*i.PublishedAtNEQ))
	}
	if len(i.PublishedAtIn) > 0 {
		predicates = append(predicates, content.PublishedAtIn(i.PublishedAtIn...))
	}
	if len(i.PublishedAtNotIn) > 0 {
		predicates = append(predicates, content.PublishedAtNotIn(i.PublishedAtNotIn...))
	}
	if i.PublishedAtGT != nil {
		predicates = append(predicates, content.PublishedAtGT(*i.PublishedAtGT))
	}
	if i.PublishedAtGTE != nil {
		predicates = append(predicates, content.PublishedAtGTE(*i.PublishedAtGTE))
	}
	if i.PublishedAtLT != nil {
		predicates = append(predicates, content.PublishedAtLT(*i.PublishedAtLT))
	}
	if i.PublishedAtLTE != nil {
		predicates = append(predicates, content.PublishedAtLTE(*i.PublishedAtLTE))
	}
	if i.PublishedAtIsNil {
		predicates = append(predicates, content.PublishedAtIsNil())
	}
	if i.PublishedAtNotNil {
		predicates = append(predicates, content.PublishedAtNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return content.And(predicates...), nil
	}
}

// TagWhereInput represents a where input for filtering Tag queries.
type TagWhereInput struct {
	Predicates []predicate.Tag  `json:"-"`
	Not        *TagWhereInput   `json:"not,omitempty"`
	Or         []*TagWhereInput `json:"or,omitempty"`
	And        []*TagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "comment" field predicates.
	Comment             *string  `json:"comment,omitempty"`
	CommentNEQ          *string  `json:"commentNEQ,omitempty"`
	CommentIn           []string `json:"commentIn,omitempty"`
	CommentNotIn        []string `json:"commentNotIn,omitempty"`
	CommentGT           *string  `json:"commentGT,omitempty"`
	CommentGTE          *string  `json:"commentGTE,omitempty"`
	CommentLT           *string  `json:"commentLT,omitempty"`
	CommentLTE          *string  `json:"commentLTE,omitempty"`
	CommentContains     *string  `json:"commentContains,omitempty"`
	CommentHasPrefix    *string  `json:"commentHasPrefix,omitempty"`
	CommentHasSuffix    *string  `json:"commentHasSuffix,omitempty"`
	CommentIsNil        bool     `json:"commentIsNil,omitempty"`
	CommentNotNil       bool     `json:"commentNotNil,omitempty"`
	CommentEqualFold    *string  `json:"commentEqualFold,omitempty"`
	CommentContainsFold *string  `json:"commentContainsFold,omitempty"`

	// "business" edge predicates.
	HasBusiness     *bool                 `json:"hasBusiness,omitempty"`
	HasBusinessWith []*BusinessWhereInput `json:"hasBusinessWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TagWhereInput) AddPredicates(predicates ...predicate.Tag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TagWhereInput filter on the TagQuery builder.
func (i *TagWhereInput) Filter(q *TagQuery) (*TagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTagWhereInput is returned in case the TagWhereInput is empty.
var ErrEmptyTagWhereInput = errors.New("ent: empty predicate TagWhereInput")

// P returns a predicate for filtering tags.
// An error is returned if the input is empty or invalid.
func (i *TagWhereInput) P() (predicate.Tag, error) {
	var predicates []predicate.Tag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tag.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, tag.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, tag.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, tag.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, tag.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, tag.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, tag.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, tag.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, tag.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, tag.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, tag.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, tag.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, tag.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, tag.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, tag.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, tag.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, tag.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, tag.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, tag.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, tag.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, tag.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, tag.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, tag.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, tag.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, tag.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, tag.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, tag.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, tag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tag.NameContainsFold(*i.NameContainsFold))
	}
	if i.Comment != nil {
		predicates = append(predicates, tag.CommentEQ(*i.Comment))
	}
	if i.CommentNEQ != nil {
		predicates = append(predicates, tag.CommentNEQ(*i.CommentNEQ))
	}
	if len(i.CommentIn) > 0 {
		predicates = append(predicates, tag.CommentIn(i.CommentIn...))
	}
	if len(i.CommentNotIn) > 0 {
		predicates = append(predicates, tag.CommentNotIn(i.CommentNotIn...))
	}
	if i.CommentGT != nil {
		predicates = append(predicates, tag.CommentGT(*i.CommentGT))
	}
	if i.CommentGTE != nil {
		predicates = append(predicates, tag.CommentGTE(*i.CommentGTE))
	}
	if i.CommentLT != nil {
		predicates = append(predicates, tag.CommentLT(*i.CommentLT))
	}
	if i.CommentLTE != nil {
		predicates = append(predicates, tag.CommentLTE(*i.CommentLTE))
	}
	if i.CommentContains != nil {
		predicates = append(predicates, tag.CommentContains(*i.CommentContains))
	}
	if i.CommentHasPrefix != nil {
		predicates = append(predicates, tag.CommentHasPrefix(*i.CommentHasPrefix))
	}
	if i.CommentHasSuffix != nil {
		predicates = append(predicates, tag.CommentHasSuffix(*i.CommentHasSuffix))
	}
	if i.CommentIsNil {
		predicates = append(predicates, tag.CommentIsNil())
	}
	if i.CommentNotNil {
		predicates = append(predicates, tag.CommentNotNil())
	}
	if i.CommentEqualFold != nil {
		predicates = append(predicates, tag.CommentEqualFold(*i.CommentEqualFold))
	}
	if i.CommentContainsFold != nil {
		predicates = append(predicates, tag.CommentContainsFold(*i.CommentContainsFold))
	}

	if i.HasBusiness != nil {
		p := tag.HasBusiness()
		if !*i.HasBusiness {
			p = tag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBusinessWith) > 0 {
		with := make([]predicate.Business, 0, len(i.HasBusinessWith))
		for _, w := range i.HasBusinessWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBusinessWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tag.HasBusinessWith(with...))
	}
	if i.HasUser != nil {
		p := tag.HasUser()
		if !*i.HasUser {
			p = tag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tag.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tag.And(predicates...), nil
	}
}

// TimetableWhereInput represents a where input for filtering Timetable queries.
type TimetableWhereInput struct {
	Predicates []predicate.Timetable  `json:"-"`
	Not        *TimetableWhereInput   `json:"not,omitempty"`
	Or         []*TimetableWhereInput `json:"or,omitempty"`
	And        []*TimetableWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "timetable_type" field predicates.
	TimetableType      *timetable.TimetableType  `json:"timetableType,omitempty"`
	TimetableTypeNEQ   *timetable.TimetableType  `json:"timetableTypeNEQ,omitempty"`
	TimetableTypeIn    []timetable.TimetableType `json:"timetableTypeIn,omitempty"`
	TimetableTypeNotIn []timetable.TimetableType `json:"timetableTypeNotIn,omitempty"`

	// "datetime_from" field predicates.
	DatetimeFrom      *time.Time  `json:"datetimeFrom,omitempty"`
	DatetimeFromNEQ   *time.Time  `json:"datetimeFromNEQ,omitempty"`
	DatetimeFromIn    []time.Time `json:"datetimeFromIn,omitempty"`
	DatetimeFromNotIn []time.Time `json:"datetimeFromNotIn,omitempty"`
	DatetimeFromGT    *time.Time  `json:"datetimeFromGT,omitempty"`
	DatetimeFromGTE   *time.Time  `json:"datetimeFromGTE,omitempty"`
	DatetimeFromLT    *time.Time  `json:"datetimeFromLT,omitempty"`
	DatetimeFromLTE   *time.Time  `json:"datetimeFromLTE,omitempty"`

	// "duration" field predicates.
	Duration       *uint8  `json:"duration,omitempty"`
	DurationNEQ    *uint8  `json:"durationNEQ,omitempty"`
	DurationIn     []uint8 `json:"durationIn,omitempty"`
	DurationNotIn  []uint8 `json:"durationNotIn,omitempty"`
	DurationGT     *uint8  `json:"durationGT,omitempty"`
	DurationGTE    *uint8  `json:"durationGTE,omitempty"`
	DurationLT     *uint8  `json:"durationLT,omitempty"`
	DurationLTE    *uint8  `json:"durationLTE,omitempty"`
	DurationIsNil  bool    `json:"durationIsNil,omitempty"`
	DurationNotNil bool    `json:"durationNotNil,omitempty"`

	// "datetime_to" field predicates.
	DatetimeTo       *time.Time  `json:"datetimeTo,omitempty"`
	DatetimeToNEQ    *time.Time  `json:"datetimeToNEQ,omitempty"`
	DatetimeToIn     []time.Time `json:"datetimeToIn,omitempty"`
	DatetimeToNotIn  []time.Time `json:"datetimeToNotIn,omitempty"`
	DatetimeToGT     *time.Time  `json:"datetimeToGT,omitempty"`
	DatetimeToGTE    *time.Time  `json:"datetimeToGTE,omitempty"`
	DatetimeToLT     *time.Time  `json:"datetimeToLT,omitempty"`
	DatetimeToLTE    *time.Time  `json:"datetimeToLTE,omitempty"`
	DatetimeToIsNil  bool        `json:"datetimeToIsNil,omitempty"`
	DatetimeToNotNil bool        `json:"datetimeToNotNil,omitempty"`

	// "time_whole_day" field predicates.
	TimeWholeDay    *bool `json:"timeWholeDay,omitempty"`
	TimeWholeDayNEQ *bool `json:"timeWholeDayNEQ,omitempty"`

	// "comment" field predicates.
	Comment             *string  `json:"comment,omitempty"`
	CommentNEQ          *string  `json:"commentNEQ,omitempty"`
	CommentIn           []string `json:"commentIn,omitempty"`
	CommentNotIn        []string `json:"commentNotIn,omitempty"`
	CommentGT           *string  `json:"commentGT,omitempty"`
	CommentGTE          *string  `json:"commentGTE,omitempty"`
	CommentLT           *string  `json:"commentLT,omitempty"`
	CommentLTE          *string  `json:"commentLTE,omitempty"`
	CommentContains     *string  `json:"commentContains,omitempty"`
	CommentHasPrefix    *string  `json:"commentHasPrefix,omitempty"`
	CommentHasSuffix    *string  `json:"commentHasSuffix,omitempty"`
	CommentIsNil        bool     `json:"commentIsNil,omitempty"`
	CommentNotNil       bool     `json:"commentNotNil,omitempty"`
	CommentEqualFold    *string  `json:"commentEqualFold,omitempty"`
	CommentContainsFold *string  `json:"commentContainsFold,omitempty"`

	// "availability_by_phone" field predicates.
	AvailabilityByPhone             *string  `json:"availabilityByPhone,omitempty"`
	AvailabilityByPhoneNEQ          *string  `json:"availabilityByPhoneNEQ,omitempty"`
	AvailabilityByPhoneIn           []string `json:"availabilityByPhoneIn,omitempty"`
	AvailabilityByPhoneNotIn        []string `json:"availabilityByPhoneNotIn,omitempty"`
	AvailabilityByPhoneGT           *string  `json:"availabilityByPhoneGT,omitempty"`
	AvailabilityByPhoneGTE          *string  `json:"availabilityByPhoneGTE,omitempty"`
	AvailabilityByPhoneLT           *string  `json:"availabilityByPhoneLT,omitempty"`
	AvailabilityByPhoneLTE          *string  `json:"availabilityByPhoneLTE,omitempty"`
	AvailabilityByPhoneContains     *string  `json:"availabilityByPhoneContains,omitempty"`
	AvailabilityByPhoneHasPrefix    *string  `json:"availabilityByPhoneHasPrefix,omitempty"`
	AvailabilityByPhoneHasSuffix    *string  `json:"availabilityByPhoneHasSuffix,omitempty"`
	AvailabilityByPhoneIsNil        bool     `json:"availabilityByPhoneIsNil,omitempty"`
	AvailabilityByPhoneNotNil       bool     `json:"availabilityByPhoneNotNil,omitempty"`
	AvailabilityByPhoneEqualFold    *string  `json:"availabilityByPhoneEqualFold,omitempty"`
	AvailabilityByPhoneContainsFold *string  `json:"availabilityByPhoneContainsFold,omitempty"`

	// "availability_by_email" field predicates.
	AvailabilityByEmail             *string  `json:"availabilityByEmail,omitempty"`
	AvailabilityByEmailNEQ          *string  `json:"availabilityByEmailNEQ,omitempty"`
	AvailabilityByEmailIn           []string `json:"availabilityByEmailIn,omitempty"`
	AvailabilityByEmailNotIn        []string `json:"availabilityByEmailNotIn,omitempty"`
	AvailabilityByEmailGT           *string  `json:"availabilityByEmailGT,omitempty"`
	AvailabilityByEmailGTE          *string  `json:"availabilityByEmailGTE,omitempty"`
	AvailabilityByEmailLT           *string  `json:"availabilityByEmailLT,omitempty"`
	AvailabilityByEmailLTE          *string  `json:"availabilityByEmailLTE,omitempty"`
	AvailabilityByEmailContains     *string  `json:"availabilityByEmailContains,omitempty"`
	AvailabilityByEmailHasPrefix    *string  `json:"availabilityByEmailHasPrefix,omitempty"`
	AvailabilityByEmailHasSuffix    *string  `json:"availabilityByEmailHasSuffix,omitempty"`
	AvailabilityByEmailIsNil        bool     `json:"availabilityByEmailIsNil,omitempty"`
	AvailabilityByEmailNotNil       bool     `json:"availabilityByEmailNotNil,omitempty"`
	AvailabilityByEmailEqualFold    *string  `json:"availabilityByEmailEqualFold,omitempty"`
	AvailabilityByEmailContainsFold *string  `json:"availabilityByEmailContainsFold,omitempty"`

	// "availability_by_sms" field predicates.
	AvailabilityBySms             *string  `json:"availabilityBySms,omitempty"`
	AvailabilityBySmsNEQ          *string  `json:"availabilityBySmsNEQ,omitempty"`
	AvailabilityBySmsIn           []string `json:"availabilityBySmsIn,omitempty"`
	AvailabilityBySmsNotIn        []string `json:"availabilityBySmsNotIn,omitempty"`
	AvailabilityBySmsGT           *string  `json:"availabilityBySmsGT,omitempty"`
	AvailabilityBySmsGTE          *string  `json:"availabilityBySmsGTE,omitempty"`
	AvailabilityBySmsLT           *string  `json:"availabilityBySmsLT,omitempty"`
	AvailabilityBySmsLTE          *string  `json:"availabilityBySmsLTE,omitempty"`
	AvailabilityBySmsContains     *string  `json:"availabilityBySmsContains,omitempty"`
	AvailabilityBySmsHasPrefix    *string  `json:"availabilityBySmsHasPrefix,omitempty"`
	AvailabilityBySmsHasSuffix    *string  `json:"availabilityBySmsHasSuffix,omitempty"`
	AvailabilityBySmsIsNil        bool     `json:"availabilityBySmsIsNil,omitempty"`
	AvailabilityBySmsNotNil       bool     `json:"availabilityBySmsNotNil,omitempty"`
	AvailabilityBySmsEqualFold    *string  `json:"availabilityBySmsEqualFold,omitempty"`
	AvailabilityBySmsContainsFold *string  `json:"availabilityBySmsContainsFold,omitempty"`

	// "availability_by_whatsapp" field predicates.
	AvailabilityByWhatsapp             *string  `json:"availabilityByWhatsapp,omitempty"`
	AvailabilityByWhatsappNEQ          *string  `json:"availabilityByWhatsappNEQ,omitempty"`
	AvailabilityByWhatsappIn           []string `json:"availabilityByWhatsappIn,omitempty"`
	AvailabilityByWhatsappNotIn        []string `json:"availabilityByWhatsappNotIn,omitempty"`
	AvailabilityByWhatsappGT           *string  `json:"availabilityByWhatsappGT,omitempty"`
	AvailabilityByWhatsappGTE          *string  `json:"availabilityByWhatsappGTE,omitempty"`
	AvailabilityByWhatsappLT           *string  `json:"availabilityByWhatsappLT,omitempty"`
	AvailabilityByWhatsappLTE          *string  `json:"availabilityByWhatsappLTE,omitempty"`
	AvailabilityByWhatsappContains     *string  `json:"availabilityByWhatsappContains,omitempty"`
	AvailabilityByWhatsappHasPrefix    *string  `json:"availabilityByWhatsappHasPrefix,omitempty"`
	AvailabilityByWhatsappHasSuffix    *string  `json:"availabilityByWhatsappHasSuffix,omitempty"`
	AvailabilityByWhatsappIsNil        bool     `json:"availabilityByWhatsappIsNil,omitempty"`
	AvailabilityByWhatsappNotNil       bool     `json:"availabilityByWhatsappNotNil,omitempty"`
	AvailabilityByWhatsappEqualFold    *string  `json:"availabilityByWhatsappEqualFold,omitempty"`
	AvailabilityByWhatsappContainsFold *string  `json:"availabilityByWhatsappContainsFold,omitempty"`

	// "address" edge predicates.
	HasAddress     *bool                `json:"hasAddress,omitempty"`
	HasAddressWith []*AddressWhereInput `json:"hasAddressWith,omitempty"`

	// "users_on_duty" edge predicates.
	HasUsersOnDuty     *bool             `json:"hasUsersOnDuty,omitempty"`
	HasUsersOnDutyWith []*UserWhereInput `json:"hasUsersOnDutyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TimetableWhereInput) AddPredicates(predicates ...predicate.Timetable) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TimetableWhereInput filter on the TimetableQuery builder.
func (i *TimetableWhereInput) Filter(q *TimetableQuery) (*TimetableQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTimetableWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTimetableWhereInput is returned in case the TimetableWhereInput is empty.
var ErrEmptyTimetableWhereInput = errors.New("ent: empty predicate TimetableWhereInput")

// P returns a predicate for filtering timetables.
// An error is returned if the input is empty or invalid.
func (i *TimetableWhereInput) P() (predicate.Timetable, error) {
	var predicates []predicate.Timetable
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, timetable.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Timetable, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, timetable.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Timetable, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, timetable.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, timetable.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, timetable.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, timetable.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, timetable.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, timetable.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, timetable.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, timetable.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, timetable.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, timetable.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, timetable.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, timetable.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, timetable.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, timetable.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, timetable.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, timetable.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, timetable.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, timetable.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, timetable.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, timetable.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, timetable.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, timetable.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, timetable.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, timetable.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, timetable.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, timetable.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, timetable.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, timetable.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, timetable.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, timetable.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, timetable.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, timetable.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, timetable.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, timetable.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, timetable.DeletedAtNotNil())
	}
	if i.TimetableType != nil {
		predicates = append(predicates, timetable.TimetableTypeEQ(*i.TimetableType))
	}
	if i.TimetableTypeNEQ != nil {
		predicates = append(predicates, timetable.TimetableTypeNEQ(*i.TimetableTypeNEQ))
	}
	if len(i.TimetableTypeIn) > 0 {
		predicates = append(predicates, timetable.TimetableTypeIn(i.TimetableTypeIn...))
	}
	if len(i.TimetableTypeNotIn) > 0 {
		predicates = append(predicates, timetable.TimetableTypeNotIn(i.TimetableTypeNotIn...))
	}
	if i.DatetimeFrom != nil {
		predicates = append(predicates, timetable.DatetimeFromEQ(*i.DatetimeFrom))
	}
	if i.DatetimeFromNEQ != nil {
		predicates = append(predicates, timetable.DatetimeFromNEQ(*i.DatetimeFromNEQ))
	}
	if len(i.DatetimeFromIn) > 0 {
		predicates = append(predicates, timetable.DatetimeFromIn(i.DatetimeFromIn...))
	}
	if len(i.DatetimeFromNotIn) > 0 {
		predicates = append(predicates, timetable.DatetimeFromNotIn(i.DatetimeFromNotIn...))
	}
	if i.DatetimeFromGT != nil {
		predicates = append(predicates, timetable.DatetimeFromGT(*i.DatetimeFromGT))
	}
	if i.DatetimeFromGTE != nil {
		predicates = append(predicates, timetable.DatetimeFromGTE(*i.DatetimeFromGTE))
	}
	if i.DatetimeFromLT != nil {
		predicates = append(predicates, timetable.DatetimeFromLT(*i.DatetimeFromLT))
	}
	if i.DatetimeFromLTE != nil {
		predicates = append(predicates, timetable.DatetimeFromLTE(*i.DatetimeFromLTE))
	}
	if i.Duration != nil {
		predicates = append(predicates, timetable.DurationEQ(*i.Duration))
	}
	if i.DurationNEQ != nil {
		predicates = append(predicates, timetable.DurationNEQ(*i.DurationNEQ))
	}
	if len(i.DurationIn) > 0 {
		predicates = append(predicates, timetable.DurationIn(i.DurationIn...))
	}
	if len(i.DurationNotIn) > 0 {
		predicates = append(predicates, timetable.DurationNotIn(i.DurationNotIn...))
	}
	if i.DurationGT != nil {
		predicates = append(predicates, timetable.DurationGT(*i.DurationGT))
	}
	if i.DurationGTE != nil {
		predicates = append(predicates, timetable.DurationGTE(*i.DurationGTE))
	}
	if i.DurationLT != nil {
		predicates = append(predicates, timetable.DurationLT(*i.DurationLT))
	}
	if i.DurationLTE != nil {
		predicates = append(predicates, timetable.DurationLTE(*i.DurationLTE))
	}
	if i.DurationIsNil {
		predicates = append(predicates, timetable.DurationIsNil())
	}
	if i.DurationNotNil {
		predicates = append(predicates, timetable.DurationNotNil())
	}
	if i.DatetimeTo != nil {
		predicates = append(predicates, timetable.DatetimeToEQ(*i.DatetimeTo))
	}
	if i.DatetimeToNEQ != nil {
		predicates = append(predicates, timetable.DatetimeToNEQ(*i.DatetimeToNEQ))
	}
	if len(i.DatetimeToIn) > 0 {
		predicates = append(predicates, timetable.DatetimeToIn(i.DatetimeToIn...))
	}
	if len(i.DatetimeToNotIn) > 0 {
		predicates = append(predicates, timetable.DatetimeToNotIn(i.DatetimeToNotIn...))
	}
	if i.DatetimeToGT != nil {
		predicates = append(predicates, timetable.DatetimeToGT(*i.DatetimeToGT))
	}
	if i.DatetimeToGTE != nil {
		predicates = append(predicates, timetable.DatetimeToGTE(*i.DatetimeToGTE))
	}
	if i.DatetimeToLT != nil {
		predicates = append(predicates, timetable.DatetimeToLT(*i.DatetimeToLT))
	}
	if i.DatetimeToLTE != nil {
		predicates = append(predicates, timetable.DatetimeToLTE(*i.DatetimeToLTE))
	}
	if i.DatetimeToIsNil {
		predicates = append(predicates, timetable.DatetimeToIsNil())
	}
	if i.DatetimeToNotNil {
		predicates = append(predicates, timetable.DatetimeToNotNil())
	}
	if i.TimeWholeDay != nil {
		predicates = append(predicates, timetable.TimeWholeDayEQ(*i.TimeWholeDay))
	}
	if i.TimeWholeDayNEQ != nil {
		predicates = append(predicates, timetable.TimeWholeDayNEQ(*i.TimeWholeDayNEQ))
	}
	if i.Comment != nil {
		predicates = append(predicates, timetable.CommentEQ(*i.Comment))
	}
	if i.CommentNEQ != nil {
		predicates = append(predicates, timetable.CommentNEQ(*i.CommentNEQ))
	}
	if len(i.CommentIn) > 0 {
		predicates = append(predicates, timetable.CommentIn(i.CommentIn...))
	}
	if len(i.CommentNotIn) > 0 {
		predicates = append(predicates, timetable.CommentNotIn(i.CommentNotIn...))
	}
	if i.CommentGT != nil {
		predicates = append(predicates, timetable.CommentGT(*i.CommentGT))
	}
	if i.CommentGTE != nil {
		predicates = append(predicates, timetable.CommentGTE(*i.CommentGTE))
	}
	if i.CommentLT != nil {
		predicates = append(predicates, timetable.CommentLT(*i.CommentLT))
	}
	if i.CommentLTE != nil {
		predicates = append(predicates, timetable.CommentLTE(*i.CommentLTE))
	}
	if i.CommentContains != nil {
		predicates = append(predicates, timetable.CommentContains(*i.CommentContains))
	}
	if i.CommentHasPrefix != nil {
		predicates = append(predicates, timetable.CommentHasPrefix(*i.CommentHasPrefix))
	}
	if i.CommentHasSuffix != nil {
		predicates = append(predicates, timetable.CommentHasSuffix(*i.CommentHasSuffix))
	}
	if i.CommentIsNil {
		predicates = append(predicates, timetable.CommentIsNil())
	}
	if i.CommentNotNil {
		predicates = append(predicates, timetable.CommentNotNil())
	}
	if i.CommentEqualFold != nil {
		predicates = append(predicates, timetable.CommentEqualFold(*i.CommentEqualFold))
	}
	if i.CommentContainsFold != nil {
		predicates = append(predicates, timetable.CommentContainsFold(*i.CommentContainsFold))
	}
	if i.AvailabilityByPhone != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneEQ(*i.AvailabilityByPhone))
	}
	if i.AvailabilityByPhoneNEQ != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneNEQ(*i.AvailabilityByPhoneNEQ))
	}
	if len(i.AvailabilityByPhoneIn) > 0 {
		predicates = append(predicates, timetable.AvailabilityByPhoneIn(i.AvailabilityByPhoneIn...))
	}
	if len(i.AvailabilityByPhoneNotIn) > 0 {
		predicates = append(predicates, timetable.AvailabilityByPhoneNotIn(i.AvailabilityByPhoneNotIn...))
	}
	if i.AvailabilityByPhoneGT != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneGT(*i.AvailabilityByPhoneGT))
	}
	if i.AvailabilityByPhoneGTE != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneGTE(*i.AvailabilityByPhoneGTE))
	}
	if i.AvailabilityByPhoneLT != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneLT(*i.AvailabilityByPhoneLT))
	}
	if i.AvailabilityByPhoneLTE != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneLTE(*i.AvailabilityByPhoneLTE))
	}
	if i.AvailabilityByPhoneContains != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneContains(*i.AvailabilityByPhoneContains))
	}
	if i.AvailabilityByPhoneHasPrefix != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneHasPrefix(*i.AvailabilityByPhoneHasPrefix))
	}
	if i.AvailabilityByPhoneHasSuffix != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneHasSuffix(*i.AvailabilityByPhoneHasSuffix))
	}
	if i.AvailabilityByPhoneIsNil {
		predicates = append(predicates, timetable.AvailabilityByPhoneIsNil())
	}
	if i.AvailabilityByPhoneNotNil {
		predicates = append(predicates, timetable.AvailabilityByPhoneNotNil())
	}
	if i.AvailabilityByPhoneEqualFold != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneEqualFold(*i.AvailabilityByPhoneEqualFold))
	}
	if i.AvailabilityByPhoneContainsFold != nil {
		predicates = append(predicates, timetable.AvailabilityByPhoneContainsFold(*i.AvailabilityByPhoneContainsFold))
	}
	if i.AvailabilityByEmail != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailEQ(*i.AvailabilityByEmail))
	}
	if i.AvailabilityByEmailNEQ != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailNEQ(*i.AvailabilityByEmailNEQ))
	}
	if len(i.AvailabilityByEmailIn) > 0 {
		predicates = append(predicates, timetable.AvailabilityByEmailIn(i.AvailabilityByEmailIn...))
	}
	if len(i.AvailabilityByEmailNotIn) > 0 {
		predicates = append(predicates, timetable.AvailabilityByEmailNotIn(i.AvailabilityByEmailNotIn...))
	}
	if i.AvailabilityByEmailGT != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailGT(*i.AvailabilityByEmailGT))
	}
	if i.AvailabilityByEmailGTE != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailGTE(*i.AvailabilityByEmailGTE))
	}
	if i.AvailabilityByEmailLT != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailLT(*i.AvailabilityByEmailLT))
	}
	if i.AvailabilityByEmailLTE != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailLTE(*i.AvailabilityByEmailLTE))
	}
	if i.AvailabilityByEmailContains != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailContains(*i.AvailabilityByEmailContains))
	}
	if i.AvailabilityByEmailHasPrefix != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailHasPrefix(*i.AvailabilityByEmailHasPrefix))
	}
	if i.AvailabilityByEmailHasSuffix != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailHasSuffix(*i.AvailabilityByEmailHasSuffix))
	}
	if i.AvailabilityByEmailIsNil {
		predicates = append(predicates, timetable.AvailabilityByEmailIsNil())
	}
	if i.AvailabilityByEmailNotNil {
		predicates = append(predicates, timetable.AvailabilityByEmailNotNil())
	}
	if i.AvailabilityByEmailEqualFold != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailEqualFold(*i.AvailabilityByEmailEqualFold))
	}
	if i.AvailabilityByEmailContainsFold != nil {
		predicates = append(predicates, timetable.AvailabilityByEmailContainsFold(*i.AvailabilityByEmailContainsFold))
	}
	if i.AvailabilityBySms != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsEQ(*i.AvailabilityBySms))
	}
	if i.AvailabilityBySmsNEQ != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsNEQ(*i.AvailabilityBySmsNEQ))
	}
	if len(i.AvailabilityBySmsIn) > 0 {
		predicates = append(predicates, timetable.AvailabilityBySmsIn(i.AvailabilityBySmsIn...))
	}
	if len(i.AvailabilityBySmsNotIn) > 0 {
		predicates = append(predicates, timetable.AvailabilityBySmsNotIn(i.AvailabilityBySmsNotIn...))
	}
	if i.AvailabilityBySmsGT != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsGT(*i.AvailabilityBySmsGT))
	}
	if i.AvailabilityBySmsGTE != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsGTE(*i.AvailabilityBySmsGTE))
	}
	if i.AvailabilityBySmsLT != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsLT(*i.AvailabilityBySmsLT))
	}
	if i.AvailabilityBySmsLTE != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsLTE(*i.AvailabilityBySmsLTE))
	}
	if i.AvailabilityBySmsContains != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsContains(*i.AvailabilityBySmsContains))
	}
	if i.AvailabilityBySmsHasPrefix != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsHasPrefix(*i.AvailabilityBySmsHasPrefix))
	}
	if i.AvailabilityBySmsHasSuffix != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsHasSuffix(*i.AvailabilityBySmsHasSuffix))
	}
	if i.AvailabilityBySmsIsNil {
		predicates = append(predicates, timetable.AvailabilityBySmsIsNil())
	}
	if i.AvailabilityBySmsNotNil {
		predicates = append(predicates, timetable.AvailabilityBySmsNotNil())
	}
	if i.AvailabilityBySmsEqualFold != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsEqualFold(*i.AvailabilityBySmsEqualFold))
	}
	if i.AvailabilityBySmsContainsFold != nil {
		predicates = append(predicates, timetable.AvailabilityBySmsContainsFold(*i.AvailabilityBySmsContainsFold))
	}
	if i.AvailabilityByWhatsapp != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappEQ(*i.AvailabilityByWhatsapp))
	}
	if i.AvailabilityByWhatsappNEQ != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappNEQ(*i.AvailabilityByWhatsappNEQ))
	}
	if len(i.AvailabilityByWhatsappIn) > 0 {
		predicates = append(predicates, timetable.AvailabilityByWhatsappIn(i.AvailabilityByWhatsappIn...))
	}
	if len(i.AvailabilityByWhatsappNotIn) > 0 {
		predicates = append(predicates, timetable.AvailabilityByWhatsappNotIn(i.AvailabilityByWhatsappNotIn...))
	}
	if i.AvailabilityByWhatsappGT != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappGT(*i.AvailabilityByWhatsappGT))
	}
	if i.AvailabilityByWhatsappGTE != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappGTE(*i.AvailabilityByWhatsappGTE))
	}
	if i.AvailabilityByWhatsappLT != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappLT(*i.AvailabilityByWhatsappLT))
	}
	if i.AvailabilityByWhatsappLTE != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappLTE(*i.AvailabilityByWhatsappLTE))
	}
	if i.AvailabilityByWhatsappContains != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappContains(*i.AvailabilityByWhatsappContains))
	}
	if i.AvailabilityByWhatsappHasPrefix != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappHasPrefix(*i.AvailabilityByWhatsappHasPrefix))
	}
	if i.AvailabilityByWhatsappHasSuffix != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappHasSuffix(*i.AvailabilityByWhatsappHasSuffix))
	}
	if i.AvailabilityByWhatsappIsNil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappIsNil())
	}
	if i.AvailabilityByWhatsappNotNil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappNotNil())
	}
	if i.AvailabilityByWhatsappEqualFold != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappEqualFold(*i.AvailabilityByWhatsappEqualFold))
	}
	if i.AvailabilityByWhatsappContainsFold != nil {
		predicates = append(predicates, timetable.AvailabilityByWhatsappContainsFold(*i.AvailabilityByWhatsappContainsFold))
	}

	if i.HasAddress != nil {
		p := timetable.HasAddress()
		if !*i.HasAddress {
			p = timetable.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAddressWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasAddressWith))
		for _, w := range i.HasAddressWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAddressWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, timetable.HasAddressWith(with...))
	}
	if i.HasUsersOnDuty != nil {
		p := timetable.HasUsersOnDuty()
		if !*i.HasUsersOnDuty {
			p = timetable.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersOnDutyWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersOnDutyWith))
		for _, w := range i.HasUsersOnDutyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersOnDutyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, timetable.HasUsersOnDutyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTimetableWhereInput
	case 1:
		return predicates[0], nil
	default:
		return timetable.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "use_publicapi" field predicates.
	UsePublicapi             *string  `json:"usePublicapi,omitempty"`
	UsePublicapiNEQ          *string  `json:"usePublicapiNEQ,omitempty"`
	UsePublicapiIn           []string `json:"usePublicapiIn,omitempty"`
	UsePublicapiNotIn        []string `json:"usePublicapiNotIn,omitempty"`
	UsePublicapiGT           *string  `json:"usePublicapiGT,omitempty"`
	UsePublicapiGTE          *string  `json:"usePublicapiGTE,omitempty"`
	UsePublicapiLT           *string  `json:"usePublicapiLT,omitempty"`
	UsePublicapiLTE          *string  `json:"usePublicapiLTE,omitempty"`
	UsePublicapiContains     *string  `json:"usePublicapiContains,omitempty"`
	UsePublicapiHasPrefix    *string  `json:"usePublicapiHasPrefix,omitempty"`
	UsePublicapiHasSuffix    *string  `json:"usePublicapiHasSuffix,omitempty"`
	UsePublicapiEqualFold    *string  `json:"usePublicapiEqualFold,omitempty"`
	UsePublicapiContainsFold *string  `json:"usePublicapiContainsFold,omitempty"`

	// "login" field predicates.
	Login             *string  `json:"login,omitempty"`
	LoginNEQ          *string  `json:"loginNEQ,omitempty"`
	LoginIn           []string `json:"loginIn,omitempty"`
	LoginNotIn        []string `json:"loginNotIn,omitempty"`
	LoginGT           *string  `json:"loginGT,omitempty"`
	LoginGTE          *string  `json:"loginGTE,omitempty"`
	LoginLT           *string  `json:"loginLT,omitempty"`
	LoginLTE          *string  `json:"loginLTE,omitempty"`
	LoginContains     *string  `json:"loginContains,omitempty"`
	LoginHasPrefix    *string  `json:"loginHasPrefix,omitempty"`
	LoginHasSuffix    *string  `json:"loginHasSuffix,omitempty"`
	LoginEqualFold    *string  `json:"loginEqualFold,omitempty"`
	LoginContainsFold *string  `json:"loginContainsFold,omitempty"`

	// "surname" field predicates.
	Surname             *string  `json:"surname,omitempty"`
	SurnameNEQ          *string  `json:"surnameNEQ,omitempty"`
	SurnameIn           []string `json:"surnameIn,omitempty"`
	SurnameNotIn        []string `json:"surnameNotIn,omitempty"`
	SurnameGT           *string  `json:"surnameGT,omitempty"`
	SurnameGTE          *string  `json:"surnameGTE,omitempty"`
	SurnameLT           *string  `json:"surnameLT,omitempty"`
	SurnameLTE          *string  `json:"surnameLTE,omitempty"`
	SurnameContains     *string  `json:"surnameContains,omitempty"`
	SurnameHasPrefix    *string  `json:"surnameHasPrefix,omitempty"`
	SurnameHasSuffix    *string  `json:"surnameHasSuffix,omitempty"`
	SurnameEqualFold    *string  `json:"surnameEqualFold,omitempty"`
	SurnameContainsFold *string  `json:"surnameContainsFold,omitempty"`

	// "firstname" field predicates.
	Firstname             *string  `json:"firstname,omitempty"`
	FirstnameNEQ          *string  `json:"firstnameNEQ,omitempty"`
	FirstnameIn           []string `json:"firstnameIn,omitempty"`
	FirstnameNotIn        []string `json:"firstnameNotIn,omitempty"`
	FirstnameGT           *string  `json:"firstnameGT,omitempty"`
	FirstnameGTE          *string  `json:"firstnameGTE,omitempty"`
	FirstnameLT           *string  `json:"firstnameLT,omitempty"`
	FirstnameLTE          *string  `json:"firstnameLTE,omitempty"`
	FirstnameContains     *string  `json:"firstnameContains,omitempty"`
	FirstnameHasPrefix    *string  `json:"firstnameHasPrefix,omitempty"`
	FirstnameHasSuffix    *string  `json:"firstnameHasSuffix,omitempty"`
	FirstnameEqualFold    *string  `json:"firstnameEqualFold,omitempty"`
	FirstnameContainsFold *string  `json:"firstnameContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "passwordhash" field predicates.
	Passwordhash             *string  `json:"passwordhash,omitempty"`
	PasswordhashNEQ          *string  `json:"passwordhashNEQ,omitempty"`
	PasswordhashIn           []string `json:"passwordhashIn,omitempty"`
	PasswordhashNotIn        []string `json:"passwordhashNotIn,omitempty"`
	PasswordhashGT           *string  `json:"passwordhashGT,omitempty"`
	PasswordhashGTE          *string  `json:"passwordhashGTE,omitempty"`
	PasswordhashLT           *string  `json:"passwordhashLT,omitempty"`
	PasswordhashLTE          *string  `json:"passwordhashLTE,omitempty"`
	PasswordhashContains     *string  `json:"passwordhashContains,omitempty"`
	PasswordhashHasPrefix    *string  `json:"passwordhashHasPrefix,omitempty"`
	PasswordhashHasSuffix    *string  `json:"passwordhashHasSuffix,omitempty"`
	PasswordhashIsNil        bool     `json:"passwordhashIsNil,omitempty"`
	PasswordhashNotNil       bool     `json:"passwordhashNotNil,omitempty"`
	PasswordhashEqualFold    *string  `json:"passwordhashEqualFold,omitempty"`
	PasswordhashContainsFold *string  `json:"passwordhashContainsFold,omitempty"`

	// "comment" field predicates.
	Comment             *string  `json:"comment,omitempty"`
	CommentNEQ          *string  `json:"commentNEQ,omitempty"`
	CommentIn           []string `json:"commentIn,omitempty"`
	CommentNotIn        []string `json:"commentNotIn,omitempty"`
	CommentGT           *string  `json:"commentGT,omitempty"`
	CommentGTE          *string  `json:"commentGTE,omitempty"`
	CommentLT           *string  `json:"commentLT,omitempty"`
	CommentLTE          *string  `json:"commentLTE,omitempty"`
	CommentContains     *string  `json:"commentContains,omitempty"`
	CommentHasPrefix    *string  `json:"commentHasPrefix,omitempty"`
	CommentHasSuffix    *string  `json:"commentHasSuffix,omitempty"`
	CommentIsNil        bool     `json:"commentIsNil,omitempty"`
	CommentNotNil       bool     `json:"commentNotNil,omitempty"`
	CommentEqualFold    *string  `json:"commentEqualFold,omitempty"`
	CommentContainsFold *string  `json:"commentContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "role" field predicates.
	Role             *string  `json:"role,omitempty"`
	RoleNEQ          *string  `json:"roleNEQ,omitempty"`
	RoleIn           []string `json:"roleIn,omitempty"`
	RoleNotIn        []string `json:"roleNotIn,omitempty"`
	RoleGT           *string  `json:"roleGT,omitempty"`
	RoleGTE          *string  `json:"roleGTE,omitempty"`
	RoleLT           *string  `json:"roleLT,omitempty"`
	RoleLTE          *string  `json:"roleLTE,omitempty"`
	RoleContains     *string  `json:"roleContains,omitempty"`
	RoleHasPrefix    *string  `json:"roleHasPrefix,omitempty"`
	RoleHasSuffix    *string  `json:"roleHasSuffix,omitempty"`
	RoleEqualFold    *string  `json:"roleEqualFold,omitempty"`
	RoleContainsFold *string  `json:"roleContainsFold,omitempty"`

	// "businesses" edge predicates.
	HasBusinesses     *bool                 `json:"hasBusinesses,omitempty"`
	HasBusinessesWith []*BusinessWhereInput `json:"hasBusinessesWith,omitempty"`

	// "tags" edge predicates.
	HasTags     *bool            `json:"hasTags,omitempty"`
	HasTagsWith []*TagWhereInput `json:"hasTagsWith,omitempty"`

	// "timetable" edge predicates.
	HasTimetable     *bool                  `json:"hasTimetable,omitempty"`
	HasTimetableWith []*TimetableWhereInput `json:"hasTimetableWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, user.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, user.DeletedAtNotNil())
	}
	if i.UsePublicapi != nil {
		predicates = append(predicates, user.UsePublicapiEQ(*i.UsePublicapi))
	}
	if i.UsePublicapiNEQ != nil {
		predicates = append(predicates, user.UsePublicapiNEQ(*i.UsePublicapiNEQ))
	}
	if len(i.UsePublicapiIn) > 0 {
		predicates = append(predicates, user.UsePublicapiIn(i.UsePublicapiIn...))
	}
	if len(i.UsePublicapiNotIn) > 0 {
		predicates = append(predicates, user.UsePublicapiNotIn(i.UsePublicapiNotIn...))
	}
	if i.UsePublicapiGT != nil {
		predicates = append(predicates, user.UsePublicapiGT(*i.UsePublicapiGT))
	}
	if i.UsePublicapiGTE != nil {
		predicates = append(predicates, user.UsePublicapiGTE(*i.UsePublicapiGTE))
	}
	if i.UsePublicapiLT != nil {
		predicates = append(predicates, user.UsePublicapiLT(*i.UsePublicapiLT))
	}
	if i.UsePublicapiLTE != nil {
		predicates = append(predicates, user.UsePublicapiLTE(*i.UsePublicapiLTE))
	}
	if i.UsePublicapiContains != nil {
		predicates = append(predicates, user.UsePublicapiContains(*i.UsePublicapiContains))
	}
	if i.UsePublicapiHasPrefix != nil {
		predicates = append(predicates, user.UsePublicapiHasPrefix(*i.UsePublicapiHasPrefix))
	}
	if i.UsePublicapiHasSuffix != nil {
		predicates = append(predicates, user.UsePublicapiHasSuffix(*i.UsePublicapiHasSuffix))
	}
	if i.UsePublicapiEqualFold != nil {
		predicates = append(predicates, user.UsePublicapiEqualFold(*i.UsePublicapiEqualFold))
	}
	if i.UsePublicapiContainsFold != nil {
		predicates = append(predicates, user.UsePublicapiContainsFold(*i.UsePublicapiContainsFold))
	}
	if i.Login != nil {
		predicates = append(predicates, user.LoginEQ(*i.Login))
	}
	if i.LoginNEQ != nil {
		predicates = append(predicates, user.LoginNEQ(*i.LoginNEQ))
	}
	if len(i.LoginIn) > 0 {
		predicates = append(predicates, user.LoginIn(i.LoginIn...))
	}
	if len(i.LoginNotIn) > 0 {
		predicates = append(predicates, user.LoginNotIn(i.LoginNotIn...))
	}
	if i.LoginGT != nil {
		predicates = append(predicates, user.LoginGT(*i.LoginGT))
	}
	if i.LoginGTE != nil {
		predicates = append(predicates, user.LoginGTE(*i.LoginGTE))
	}
	if i.LoginLT != nil {
		predicates = append(predicates, user.LoginLT(*i.LoginLT))
	}
	if i.LoginLTE != nil {
		predicates = append(predicates, user.LoginLTE(*i.LoginLTE))
	}
	if i.LoginContains != nil {
		predicates = append(predicates, user.LoginContains(*i.LoginContains))
	}
	if i.LoginHasPrefix != nil {
		predicates = append(predicates, user.LoginHasPrefix(*i.LoginHasPrefix))
	}
	if i.LoginHasSuffix != nil {
		predicates = append(predicates, user.LoginHasSuffix(*i.LoginHasSuffix))
	}
	if i.LoginEqualFold != nil {
		predicates = append(predicates, user.LoginEqualFold(*i.LoginEqualFold))
	}
	if i.LoginContainsFold != nil {
		predicates = append(predicates, user.LoginContainsFold(*i.LoginContainsFold))
	}
	if i.Surname != nil {
		predicates = append(predicates, user.SurnameEQ(*i.Surname))
	}
	if i.SurnameNEQ != nil {
		predicates = append(predicates, user.SurnameNEQ(*i.SurnameNEQ))
	}
	if len(i.SurnameIn) > 0 {
		predicates = append(predicates, user.SurnameIn(i.SurnameIn...))
	}
	if len(i.SurnameNotIn) > 0 {
		predicates = append(predicates, user.SurnameNotIn(i.SurnameNotIn...))
	}
	if i.SurnameGT != nil {
		predicates = append(predicates, user.SurnameGT(*i.SurnameGT))
	}
	if i.SurnameGTE != nil {
		predicates = append(predicates, user.SurnameGTE(*i.SurnameGTE))
	}
	if i.SurnameLT != nil {
		predicates = append(predicates, user.SurnameLT(*i.SurnameLT))
	}
	if i.SurnameLTE != nil {
		predicates = append(predicates, user.SurnameLTE(*i.SurnameLTE))
	}
	if i.SurnameContains != nil {
		predicates = append(predicates, user.SurnameContains(*i.SurnameContains))
	}
	if i.SurnameHasPrefix != nil {
		predicates = append(predicates, user.SurnameHasPrefix(*i.SurnameHasPrefix))
	}
	if i.SurnameHasSuffix != nil {
		predicates = append(predicates, user.SurnameHasSuffix(*i.SurnameHasSuffix))
	}
	if i.SurnameEqualFold != nil {
		predicates = append(predicates, user.SurnameEqualFold(*i.SurnameEqualFold))
	}
	if i.SurnameContainsFold != nil {
		predicates = append(predicates, user.SurnameContainsFold(*i.SurnameContainsFold))
	}
	if i.Firstname != nil {
		predicates = append(predicates, user.FirstnameEQ(*i.Firstname))
	}
	if i.FirstnameNEQ != nil {
		predicates = append(predicates, user.FirstnameNEQ(*i.FirstnameNEQ))
	}
	if len(i.FirstnameIn) > 0 {
		predicates = append(predicates, user.FirstnameIn(i.FirstnameIn...))
	}
	if len(i.FirstnameNotIn) > 0 {
		predicates = append(predicates, user.FirstnameNotIn(i.FirstnameNotIn...))
	}
	if i.FirstnameGT != nil {
		predicates = append(predicates, user.FirstnameGT(*i.FirstnameGT))
	}
	if i.FirstnameGTE != nil {
		predicates = append(predicates, user.FirstnameGTE(*i.FirstnameGTE))
	}
	if i.FirstnameLT != nil {
		predicates = append(predicates, user.FirstnameLT(*i.FirstnameLT))
	}
	if i.FirstnameLTE != nil {
		predicates = append(predicates, user.FirstnameLTE(*i.FirstnameLTE))
	}
	if i.FirstnameContains != nil {
		predicates = append(predicates, user.FirstnameContains(*i.FirstnameContains))
	}
	if i.FirstnameHasPrefix != nil {
		predicates = append(predicates, user.FirstnameHasPrefix(*i.FirstnameHasPrefix))
	}
	if i.FirstnameHasSuffix != nil {
		predicates = append(predicates, user.FirstnameHasSuffix(*i.FirstnameHasSuffix))
	}
	if i.FirstnameEqualFold != nil {
		predicates = append(predicates, user.FirstnameEqualFold(*i.FirstnameEqualFold))
	}
	if i.FirstnameContainsFold != nil {
		predicates = append(predicates, user.FirstnameContainsFold(*i.FirstnameContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, user.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, user.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, user.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, user.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, user.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, user.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, user.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, user.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, user.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, user.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, user.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, user.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, user.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, user.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, user.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Passwordhash != nil {
		predicates = append(predicates, user.PasswordhashEQ(*i.Passwordhash))
	}
	if i.PasswordhashNEQ != nil {
		predicates = append(predicates, user.PasswordhashNEQ(*i.PasswordhashNEQ))
	}
	if len(i.PasswordhashIn) > 0 {
		predicates = append(predicates, user.PasswordhashIn(i.PasswordhashIn...))
	}
	if len(i.PasswordhashNotIn) > 0 {
		predicates = append(predicates, user.PasswordhashNotIn(i.PasswordhashNotIn...))
	}
	if i.PasswordhashGT != nil {
		predicates = append(predicates, user.PasswordhashGT(*i.PasswordhashGT))
	}
	if i.PasswordhashGTE != nil {
		predicates = append(predicates, user.PasswordhashGTE(*i.PasswordhashGTE))
	}
	if i.PasswordhashLT != nil {
		predicates = append(predicates, user.PasswordhashLT(*i.PasswordhashLT))
	}
	if i.PasswordhashLTE != nil {
		predicates = append(predicates, user.PasswordhashLTE(*i.PasswordhashLTE))
	}
	if i.PasswordhashContains != nil {
		predicates = append(predicates, user.PasswordhashContains(*i.PasswordhashContains))
	}
	if i.PasswordhashHasPrefix != nil {
		predicates = append(predicates, user.PasswordhashHasPrefix(*i.PasswordhashHasPrefix))
	}
	if i.PasswordhashHasSuffix != nil {
		predicates = append(predicates, user.PasswordhashHasSuffix(*i.PasswordhashHasSuffix))
	}
	if i.PasswordhashIsNil {
		predicates = append(predicates, user.PasswordhashIsNil())
	}
	if i.PasswordhashNotNil {
		predicates = append(predicates, user.PasswordhashNotNil())
	}
	if i.PasswordhashEqualFold != nil {
		predicates = append(predicates, user.PasswordhashEqualFold(*i.PasswordhashEqualFold))
	}
	if i.PasswordhashContainsFold != nil {
		predicates = append(predicates, user.PasswordhashContainsFold(*i.PasswordhashContainsFold))
	}
	if i.Comment != nil {
		predicates = append(predicates, user.CommentEQ(*i.Comment))
	}
	if i.CommentNEQ != nil {
		predicates = append(predicates, user.CommentNEQ(*i.CommentNEQ))
	}
	if len(i.CommentIn) > 0 {
		predicates = append(predicates, user.CommentIn(i.CommentIn...))
	}
	if len(i.CommentNotIn) > 0 {
		predicates = append(predicates, user.CommentNotIn(i.CommentNotIn...))
	}
	if i.CommentGT != nil {
		predicates = append(predicates, user.CommentGT(*i.CommentGT))
	}
	if i.CommentGTE != nil {
		predicates = append(predicates, user.CommentGTE(*i.CommentGTE))
	}
	if i.CommentLT != nil {
		predicates = append(predicates, user.CommentLT(*i.CommentLT))
	}
	if i.CommentLTE != nil {
		predicates = append(predicates, user.CommentLTE(*i.CommentLTE))
	}
	if i.CommentContains != nil {
		predicates = append(predicates, user.CommentContains(*i.CommentContains))
	}
	if i.CommentHasPrefix != nil {
		predicates = append(predicates, user.CommentHasPrefix(*i.CommentHasPrefix))
	}
	if i.CommentHasSuffix != nil {
		predicates = append(predicates, user.CommentHasSuffix(*i.CommentHasSuffix))
	}
	if i.CommentIsNil {
		predicates = append(predicates, user.CommentIsNil())
	}
	if i.CommentNotNil {
		predicates = append(predicates, user.CommentNotNil())
	}
	if i.CommentEqualFold != nil {
		predicates = append(predicates, user.CommentEqualFold(*i.CommentEqualFold))
	}
	if i.CommentContainsFold != nil {
		predicates = append(predicates, user.CommentContainsFold(*i.CommentContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, user.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, user.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.Role != nil {
		predicates = append(predicates, user.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, user.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, user.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, user.RoleNotIn(i.RoleNotIn...))
	}
	if i.RoleGT != nil {
		predicates = append(predicates, user.RoleGT(*i.RoleGT))
	}
	if i.RoleGTE != nil {
		predicates = append(predicates, user.RoleGTE(*i.RoleGTE))
	}
	if i.RoleLT != nil {
		predicates = append(predicates, user.RoleLT(*i.RoleLT))
	}
	if i.RoleLTE != nil {
		predicates = append(predicates, user.RoleLTE(*i.RoleLTE))
	}
	if i.RoleContains != nil {
		predicates = append(predicates, user.RoleContains(*i.RoleContains))
	}
	if i.RoleHasPrefix != nil {
		predicates = append(predicates, user.RoleHasPrefix(*i.RoleHasPrefix))
	}
	if i.RoleHasSuffix != nil {
		predicates = append(predicates, user.RoleHasSuffix(*i.RoleHasSuffix))
	}
	if i.RoleEqualFold != nil {
		predicates = append(predicates, user.RoleEqualFold(*i.RoleEqualFold))
	}
	if i.RoleContainsFold != nil {
		predicates = append(predicates, user.RoleContainsFold(*i.RoleContainsFold))
	}

	if i.HasBusinesses != nil {
		p := user.HasBusinesses()
		if !*i.HasBusinesses {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBusinessesWith) > 0 {
		with := make([]predicate.Business, 0, len(i.HasBusinessesWith))
		for _, w := range i.HasBusinessesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBusinessesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasBusinessesWith(with...))
	}
	if i.HasTags != nil {
		p := user.HasTags()
		if !*i.HasTags {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTagsWith) > 0 {
		with := make([]predicate.Tag, 0, len(i.HasTagsWith))
		for _, w := range i.HasTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTagsWith(with...))
	}
	if i.HasTimetable != nil {
		p := user.HasTimetable()
		if !*i.HasTimetable {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTimetableWith) > 0 {
		with := make([]predicate.Timetable, 0, len(i.HasTimetableWith))
		for _, w := range i.HasTimetableWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTimetableWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTimetableWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
