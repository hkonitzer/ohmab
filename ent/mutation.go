// OHMAB
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"hynie.de/ohmab/ent/address"
	"hynie.de/ohmab/ent/auditlog"
	"hynie.de/ohmab/ent/business"
	"hynie.de/ohmab/ent/predicate"
	"hynie.de/ohmab/ent/tag"
	"hynie.de/ohmab/ent/timetable"
	"hynie.de/ohmab/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddress   = "Address"
	TypeAuditLog  = "AuditLog"
	TypeBusiness  = "Business"
	TypeTag       = "Tag"
	TypeTimetable = "Timetable"
	TypeUser      = "User"
)

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	addition          *string
	street            *string
	city              *string
	zip               *string
	state             *string
	country           *string
	primary           *bool
	telephone         *string
	comment           *string
	clearedFields     map[string]struct{}
	business          *uuid.UUID
	clearedbusiness   bool
	timetables        map[uuid.UUID]struct{}
	removedtimetables map[uuid.UUID]struct{}
	clearedtimetables bool
	done              bool
	oldValue          func(context.Context) (*Address, error)
	predicates        []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id uuid.UUID) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Address entities.
func (m *AddressMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AddressMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AddressMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AddressMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[address.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AddressMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[address.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AddressMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, address.FieldDeletedAt)
}

// SetAddition sets the "addition" field.
func (m *AddressMutation) SetAddition(s string) {
	m.addition = &s
}

// Addition returns the value of the "addition" field in the mutation.
func (m *AddressMutation) Addition() (r string, exists bool) {
	v := m.addition
	if v == nil {
		return
	}
	return *v, true
}

// OldAddition returns the old "addition" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddition: %w", err)
	}
	return oldValue.Addition, nil
}

// ClearAddition clears the value of the "addition" field.
func (m *AddressMutation) ClearAddition() {
	m.addition = nil
	m.clearedFields[address.FieldAddition] = struct{}{}
}

// AdditionCleared returns if the "addition" field was cleared in this mutation.
func (m *AddressMutation) AdditionCleared() bool {
	_, ok := m.clearedFields[address.FieldAddition]
	return ok
}

// ResetAddition resets all changes to the "addition" field.
func (m *AddressMutation) ResetAddition() {
	m.addition = nil
	delete(m.clearedFields, address.FieldAddition)
}

// SetStreet sets the "street" field.
func (m *AddressMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the value of the "street" field in the mutation.
func (m *AddressMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "street" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "street" field.
func (m *AddressMutation) ClearStreet() {
	m.street = nil
	m.clearedFields[address.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "street" field was cleared in this mutation.
func (m *AddressMutation) StreetCleared() bool {
	_, ok := m.clearedFields[address.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "street" field.
func (m *AddressMutation) ResetStreet() {
	m.street = nil
	delete(m.clearedFields, address.FieldStreet)
}

// SetCity sets the "city" field.
func (m *AddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *AddressMutation) ClearCity() {
	m.city = nil
	m.clearedFields[address.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *AddressMutation) CityCleared() bool {
	_, ok := m.clearedFields[address.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *AddressMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, address.FieldCity)
}

// SetZip sets the "zip" field.
func (m *AddressMutation) SetZip(s string) {
	m.zip = &s
}

// Zip returns the value of the "zip" field in the mutation.
func (m *AddressMutation) Zip() (r string, exists bool) {
	v := m.zip
	if v == nil {
		return
	}
	return *v, true
}

// OldZip returns the old "zip" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldZip(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZip: %w", err)
	}
	return oldValue.Zip, nil
}

// ClearZip clears the value of the "zip" field.
func (m *AddressMutation) ClearZip() {
	m.zip = nil
	m.clearedFields[address.FieldZip] = struct{}{}
}

// ZipCleared returns if the "zip" field was cleared in this mutation.
func (m *AddressMutation) ZipCleared() bool {
	_, ok := m.clearedFields[address.FieldZip]
	return ok
}

// ResetZip resets all changes to the "zip" field.
func (m *AddressMutation) ResetZip() {
	m.zip = nil
	delete(m.clearedFields, address.FieldZip)
}

// SetState sets the "state" field.
func (m *AddressMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AddressMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *AddressMutation) ClearState() {
	m.state = nil
	m.clearedFields[address.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *AddressMutation) StateCleared() bool {
	_, ok := m.clearedFields[address.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *AddressMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, address.FieldState)
}

// SetCountry sets the "country" field.
func (m *AddressMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AddressMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *AddressMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[address.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *AddressMutation) CountryCleared() bool {
	_, ok := m.clearedFields[address.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *AddressMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, address.FieldCountry)
}

// SetPrimary sets the "primary" field.
func (m *AddressMutation) SetPrimary(b bool) {
	m.primary = &b
}

// Primary returns the value of the "primary" field in the mutation.
func (m *AddressMutation) Primary() (r bool, exists bool) {
	v := m.primary
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimary returns the old "primary" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimary: %w", err)
	}
	return oldValue.Primary, nil
}

// ResetPrimary resets all changes to the "primary" field.
func (m *AddressMutation) ResetPrimary() {
	m.primary = nil
}

// SetTelephone sets the "telephone" field.
func (m *AddressMutation) SetTelephone(s string) {
	m.telephone = &s
}

// Telephone returns the value of the "telephone" field in the mutation.
func (m *AddressMutation) Telephone() (r string, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old "telephone" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldTelephone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelephone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// ClearTelephone clears the value of the "telephone" field.
func (m *AddressMutation) ClearTelephone() {
	m.telephone = nil
	m.clearedFields[address.FieldTelephone] = struct{}{}
}

// TelephoneCleared returns if the "telephone" field was cleared in this mutation.
func (m *AddressMutation) TelephoneCleared() bool {
	_, ok := m.clearedFields[address.FieldTelephone]
	return ok
}

// ResetTelephone resets all changes to the "telephone" field.
func (m *AddressMutation) ResetTelephone() {
	m.telephone = nil
	delete(m.clearedFields, address.FieldTelephone)
}

// SetComment sets the "comment" field.
func (m *AddressMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *AddressMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *AddressMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[address.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *AddressMutation) CommentCleared() bool {
	_, ok := m.clearedFields[address.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *AddressMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, address.FieldComment)
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *AddressMutation) SetBusinessID(id uuid.UUID) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *AddressMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *AddressMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *AddressMutation) BusinessID() (id uuid.UUID, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) BusinessIDs() (ids []uuid.UUID) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *AddressMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// AddTimetableIDs adds the "timetables" edge to the Timetable entity by ids.
func (m *AddressMutation) AddTimetableIDs(ids ...uuid.UUID) {
	if m.timetables == nil {
		m.timetables = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.timetables[ids[i]] = struct{}{}
	}
}

// ClearTimetables clears the "timetables" edge to the Timetable entity.
func (m *AddressMutation) ClearTimetables() {
	m.clearedtimetables = true
}

// TimetablesCleared reports if the "timetables" edge to the Timetable entity was cleared.
func (m *AddressMutation) TimetablesCleared() bool {
	return m.clearedtimetables
}

// RemoveTimetableIDs removes the "timetables" edge to the Timetable entity by IDs.
func (m *AddressMutation) RemoveTimetableIDs(ids ...uuid.UUID) {
	if m.removedtimetables == nil {
		m.removedtimetables = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.timetables, ids[i])
		m.removedtimetables[ids[i]] = struct{}{}
	}
}

// RemovedTimetables returns the removed IDs of the "timetables" edge to the Timetable entity.
func (m *AddressMutation) RemovedTimetablesIDs() (ids []uuid.UUID) {
	for id := range m.removedtimetables {
		ids = append(ids, id)
	}
	return
}

// TimetablesIDs returns the "timetables" edge IDs in the mutation.
func (m *AddressMutation) TimetablesIDs() (ids []uuid.UUID) {
	for id := range m.timetables {
		ids = append(ids, id)
	}
	return
}

// ResetTimetables resets all changes to the "timetables" edge.
func (m *AddressMutation) ResetTimetables() {
	m.timetables = nil
	m.clearedtimetables = false
	m.removedtimetables = nil
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Address, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, address.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, address.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, address.FieldDeletedAt)
	}
	if m.addition != nil {
		fields = append(fields, address.FieldAddition)
	}
	if m.street != nil {
		fields = append(fields, address.FieldStreet)
	}
	if m.city != nil {
		fields = append(fields, address.FieldCity)
	}
	if m.zip != nil {
		fields = append(fields, address.FieldZip)
	}
	if m.state != nil {
		fields = append(fields, address.FieldState)
	}
	if m.country != nil {
		fields = append(fields, address.FieldCountry)
	}
	if m.primary != nil {
		fields = append(fields, address.FieldPrimary)
	}
	if m.telephone != nil {
		fields = append(fields, address.FieldTelephone)
	}
	if m.comment != nil {
		fields = append(fields, address.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldCreatedAt:
		return m.CreatedAt()
	case address.FieldUpdatedAt:
		return m.UpdatedAt()
	case address.FieldDeletedAt:
		return m.DeletedAt()
	case address.FieldAddition:
		return m.Addition()
	case address.FieldStreet:
		return m.Street()
	case address.FieldCity:
		return m.City()
	case address.FieldZip:
		return m.Zip()
	case address.FieldState:
		return m.State()
	case address.FieldCountry:
		return m.Country()
	case address.FieldPrimary:
		return m.Primary()
	case address.FieldTelephone:
		return m.Telephone()
	case address.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case address.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case address.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case address.FieldAddition:
		return m.OldAddition(ctx)
	case address.FieldStreet:
		return m.OldStreet(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldZip:
		return m.OldZip(ctx)
	case address.FieldState:
		return m.OldState(ctx)
	case address.FieldCountry:
		return m.OldCountry(ctx)
	case address.FieldPrimary:
		return m.OldPrimary(ctx)
	case address.FieldTelephone:
		return m.OldTelephone(ctx)
	case address.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case address.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case address.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case address.FieldAddition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddition(v)
		return nil
	case address.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldZip:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZip(v)
		return nil
	case address.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case address.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case address.FieldPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimary(v)
		return nil
	case address.FieldTelephone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case address.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldDeletedAt) {
		fields = append(fields, address.FieldDeletedAt)
	}
	if m.FieldCleared(address.FieldAddition) {
		fields = append(fields, address.FieldAddition)
	}
	if m.FieldCleared(address.FieldStreet) {
		fields = append(fields, address.FieldStreet)
	}
	if m.FieldCleared(address.FieldCity) {
		fields = append(fields, address.FieldCity)
	}
	if m.FieldCleared(address.FieldZip) {
		fields = append(fields, address.FieldZip)
	}
	if m.FieldCleared(address.FieldState) {
		fields = append(fields, address.FieldState)
	}
	if m.FieldCleared(address.FieldCountry) {
		fields = append(fields, address.FieldCountry)
	}
	if m.FieldCleared(address.FieldTelephone) {
		fields = append(fields, address.FieldTelephone)
	}
	if m.FieldCleared(address.FieldComment) {
		fields = append(fields, address.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case address.FieldAddition:
		m.ClearAddition()
		return nil
	case address.FieldStreet:
		m.ClearStreet()
		return nil
	case address.FieldCity:
		m.ClearCity()
		return nil
	case address.FieldZip:
		m.ClearZip()
		return nil
	case address.FieldState:
		m.ClearState()
		return nil
	case address.FieldCountry:
		m.ClearCountry()
		return nil
	case address.FieldTelephone:
		m.ClearTelephone()
		return nil
	case address.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case address.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case address.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case address.FieldAddition:
		m.ResetAddition()
		return nil
	case address.FieldStreet:
		m.ResetStreet()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldZip:
		m.ResetZip()
		return nil
	case address.FieldState:
		m.ResetState()
		return nil
	case address.FieldCountry:
		m.ResetCountry()
		return nil
	case address.FieldPrimary:
		m.ResetPrimary()
		return nil
	case address.FieldTelephone:
		m.ResetTelephone()
		return nil
	case address.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business != nil {
		edges = append(edges, address.EdgeBusiness)
	}
	if m.timetables != nil {
		edges = append(edges, address.EdgeTimetables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeTimetables:
		ids := make([]ent.Value, 0, len(m.timetables))
		for id := range m.timetables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtimetables != nil {
		edges = append(edges, address.EdgeTimetables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeTimetables:
		ids := make([]ent.Value, 0, len(m.removedtimetables))
		for id := range m.removedtimetables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness {
		edges = append(edges, address.EdgeBusiness)
	}
	if m.clearedtimetables {
		edges = append(edges, address.EdgeTimetables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeBusiness:
		return m.clearedbusiness
	case address.EdgeTimetables:
		return m.clearedtimetables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case address.EdgeTimetables:
		m.ResetTimetables()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	user          *string
	action        *string
	entity_schema *string
	entity_values *map[string]string
	entity_uuid   *string
	timestamp     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuditLog, error)
	predicates    []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uuid.UUID) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUser sets the "user" field.
func (m *AuditLogMutation) SetUser(s string) {
	m.user = &s
}

// User returns the value of the "user" field in the mutation.
func (m *AuditLogMutation) User() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUser returns the old "user" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser: %w", err)
	}
	return oldValue.User, nil
}

// ResetUser resets all changes to the "user" field.
func (m *AuditLogMutation) ResetUser() {
	m.user = nil
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetEntitySchema sets the "entity_schema" field.
func (m *AuditLogMutation) SetEntitySchema(s string) {
	m.entity_schema = &s
}

// EntitySchema returns the value of the "entity_schema" field in the mutation.
func (m *AuditLogMutation) EntitySchema() (r string, exists bool) {
	v := m.entity_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitySchema returns the old "entity_schema" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldEntitySchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitySchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitySchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitySchema: %w", err)
	}
	return oldValue.EntitySchema, nil
}

// ResetEntitySchema resets all changes to the "entity_schema" field.
func (m *AuditLogMutation) ResetEntitySchema() {
	m.entity_schema = nil
}

// SetEntityValues sets the "entity_values" field.
func (m *AuditLogMutation) SetEntityValues(value map[string]string) {
	m.entity_values = &value
}

// EntityValues returns the value of the "entity_values" field in the mutation.
func (m *AuditLogMutation) EntityValues() (r map[string]string, exists bool) {
	v := m.entity_values
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityValues returns the old "entity_values" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldEntityValues(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityValues: %w", err)
	}
	return oldValue.EntityValues, nil
}

// ClearEntityValues clears the value of the "entity_values" field.
func (m *AuditLogMutation) ClearEntityValues() {
	m.entity_values = nil
	m.clearedFields[auditlog.FieldEntityValues] = struct{}{}
}

// EntityValuesCleared returns if the "entity_values" field was cleared in this mutation.
func (m *AuditLogMutation) EntityValuesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldEntityValues]
	return ok
}

// ResetEntityValues resets all changes to the "entity_values" field.
func (m *AuditLogMutation) ResetEntityValues() {
	m.entity_values = nil
	delete(m.clearedFields, auditlog.FieldEntityValues)
}

// SetEntityUUID sets the "entity_uuid" field.
func (m *AuditLogMutation) SetEntityUUID(s string) {
	m.entity_uuid = &s
}

// EntityUUID returns the value of the "entity_uuid" field in the mutation.
func (m *AuditLogMutation) EntityUUID() (r string, exists bool) {
	v := m.entity_uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityUUID returns the old "entity_uuid" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldEntityUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityUUID: %w", err)
	}
	return oldValue.EntityUUID, nil
}

// ClearEntityUUID clears the value of the "entity_uuid" field.
func (m *AuditLogMutation) ClearEntityUUID() {
	m.entity_uuid = nil
	m.clearedFields[auditlog.FieldEntityUUID] = struct{}{}
}

// EntityUUIDCleared returns if the "entity_uuid" field was cleared in this mutation.
func (m *AuditLogMutation) EntityUUIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldEntityUUID]
	return ok
}

// ResetEntityUUID resets all changes to the "entity_uuid" field.
func (m *AuditLogMutation) ResetEntityUUID() {
	m.entity_uuid = nil
	delete(m.clearedFields, auditlog.FieldEntityUUID)
}

// SetTimestamp sets the "timestamp" field.
func (m *AuditLogMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *AuditLogMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *AuditLogMutation) ResetTimestamp() {
	m.timestamp = nil
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user != nil {
		fields = append(fields, auditlog.FieldUser)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.entity_schema != nil {
		fields = append(fields, auditlog.FieldEntitySchema)
	}
	if m.entity_values != nil {
		fields = append(fields, auditlog.FieldEntityValues)
	}
	if m.entity_uuid != nil {
		fields = append(fields, auditlog.FieldEntityUUID)
	}
	if m.timestamp != nil {
		fields = append(fields, auditlog.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldUser:
		return m.User()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldEntitySchema:
		return m.EntitySchema()
	case auditlog.FieldEntityValues:
		return m.EntityValues()
	case auditlog.FieldEntityUUID:
		return m.EntityUUID()
	case auditlog.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldUser:
		return m.OldUser(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldEntitySchema:
		return m.OldEntitySchema(ctx)
	case auditlog.FieldEntityValues:
		return m.OldEntityValues(ctx)
	case auditlog.FieldEntityUUID:
		return m.OldEntityUUID(ctx)
	case auditlog.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldEntitySchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitySchema(v)
		return nil
	case auditlog.FieldEntityValues:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityValues(v)
		return nil
	case auditlog.FieldEntityUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityUUID(v)
		return nil
	case auditlog.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldEntityValues) {
		fields = append(fields, auditlog.FieldEntityValues)
	}
	if m.FieldCleared(auditlog.FieldEntityUUID) {
		fields = append(fields, auditlog.FieldEntityUUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldEntityValues:
		m.ClearEntityValues()
		return nil
	case auditlog.FieldEntityUUID:
		m.ClearEntityUUID()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldUser:
		m.ResetUser()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldEntitySchema:
		m.ResetEntitySchema()
		return nil
	case auditlog.FieldEntityValues:
		m.ResetEntityValues()
		return nil
	case auditlog.FieldEntityUUID:
		m.ResetEntityUUID()
		return nil
	case auditlog.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// BusinessMutation represents an operation that mutates the Business nodes in the graph.
type BusinessMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	name1            *string
	name2            *string
	alias            *string
	telephone        *string
	email            *string
	website          *string
	comment          *string
	active           *bool
	clearedFields    map[string]struct{}
	addresses        map[uuid.UUID]struct{}
	removedaddresses map[uuid.UUID]struct{}
	clearedaddresses bool
	tags             map[uuid.UUID]struct{}
	removedtags      map[uuid.UUID]struct{}
	clearedtags      bool
	users            *uuid.UUID
	clearedusers     bool
	done             bool
	oldValue         func(context.Context) (*Business, error)
	predicates       []predicate.Business
}

var _ ent.Mutation = (*BusinessMutation)(nil)

// businessOption allows management of the mutation configuration using functional options.
type businessOption func(*BusinessMutation)

// newBusinessMutation creates new mutation for the Business entity.
func newBusinessMutation(c config, op Op, opts ...businessOption) *BusinessMutation {
	m := &BusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessID sets the ID field of the mutation.
func withBusinessID(id uuid.UUID) businessOption {
	return func(m *BusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *Business
		)
		m.oldValue = func(ctx context.Context) (*Business, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Business.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusiness sets the old Business of the mutation.
func withBusiness(node *Business) businessOption {
	return func(m *BusinessMutation) {
		m.oldValue = func(context.Context) (*Business, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Business entities.
func (m *BusinessMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Business.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BusinessMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BusinessMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BusinessMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BusinessMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BusinessMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BusinessMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BusinessMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BusinessMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BusinessMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[business.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BusinessMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[business.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BusinessMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, business.FieldDeletedAt)
}

// SetName1 sets the "name1" field.
func (m *BusinessMutation) SetName1(s string) {
	m.name1 = &s
}

// Name1 returns the value of the "name1" field in the mutation.
func (m *BusinessMutation) Name1() (r string, exists bool) {
	v := m.name1
	if v == nil {
		return
	}
	return *v, true
}

// OldName1 returns the old "name1" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldName1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName1: %w", err)
	}
	return oldValue.Name1, nil
}

// ResetName1 resets all changes to the "name1" field.
func (m *BusinessMutation) ResetName1() {
	m.name1 = nil
}

// SetName2 sets the "name2" field.
func (m *BusinessMutation) SetName2(s string) {
	m.name2 = &s
}

// Name2 returns the value of the "name2" field in the mutation.
func (m *BusinessMutation) Name2() (r string, exists bool) {
	v := m.name2
	if v == nil {
		return
	}
	return *v, true
}

// OldName2 returns the old "name2" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldName2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName2: %w", err)
	}
	return oldValue.Name2, nil
}

// ClearName2 clears the value of the "name2" field.
func (m *BusinessMutation) ClearName2() {
	m.name2 = nil
	m.clearedFields[business.FieldName2] = struct{}{}
}

// Name2Cleared returns if the "name2" field was cleared in this mutation.
func (m *BusinessMutation) Name2Cleared() bool {
	_, ok := m.clearedFields[business.FieldName2]
	return ok
}

// ResetName2 resets all changes to the "name2" field.
func (m *BusinessMutation) ResetName2() {
	m.name2 = nil
	delete(m.clearedFields, business.FieldName2)
}

// SetAlias sets the "alias" field.
func (m *BusinessMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *BusinessMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *BusinessMutation) ResetAlias() {
	m.alias = nil
}

// SetTelephone sets the "telephone" field.
func (m *BusinessMutation) SetTelephone(s string) {
	m.telephone = &s
}

// Telephone returns the value of the "telephone" field in the mutation.
func (m *BusinessMutation) Telephone() (r string, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old "telephone" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldTelephone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelephone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// ClearTelephone clears the value of the "telephone" field.
func (m *BusinessMutation) ClearTelephone() {
	m.telephone = nil
	m.clearedFields[business.FieldTelephone] = struct{}{}
}

// TelephoneCleared returns if the "telephone" field was cleared in this mutation.
func (m *BusinessMutation) TelephoneCleared() bool {
	_, ok := m.clearedFields[business.FieldTelephone]
	return ok
}

// ResetTelephone resets all changes to the "telephone" field.
func (m *BusinessMutation) ResetTelephone() {
	m.telephone = nil
	delete(m.clearedFields, business.FieldTelephone)
}

// SetEmail sets the "email" field.
func (m *BusinessMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *BusinessMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *BusinessMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[business.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *BusinessMutation) EmailCleared() bool {
	_, ok := m.clearedFields[business.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *BusinessMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, business.FieldEmail)
}

// SetWebsite sets the "website" field.
func (m *BusinessMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *BusinessMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *BusinessMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[business.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *BusinessMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[business.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *BusinessMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, business.FieldWebsite)
}

// SetComment sets the "comment" field.
func (m *BusinessMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *BusinessMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *BusinessMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[business.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *BusinessMutation) CommentCleared() bool {
	_, ok := m.clearedFields[business.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *BusinessMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, business.FieldComment)
}

// SetActive sets the "active" field.
func (m *BusinessMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *BusinessMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *BusinessMutation) ResetActive() {
	m.active = nil
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *BusinessMutation) AddAddressIDs(ids ...uuid.UUID) {
	if m.addresses == nil {
		m.addresses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *BusinessMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *BusinessMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *BusinessMutation) RemoveAddressIDs(ids ...uuid.UUID) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *BusinessMutation) RemovedAddressesIDs() (ids []uuid.UUID) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *BusinessMutation) AddressesIDs() (ids []uuid.UUID) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *BusinessMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *BusinessMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *BusinessMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *BusinessMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *BusinessMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *BusinessMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *BusinessMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *BusinessMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *BusinessMutation) SetUsersID(id uuid.UUID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *BusinessMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *BusinessMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *BusinessMutation) UsersID() (id uuid.UUID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) UsersIDs() (ids []uuid.UUID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *BusinessMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the BusinessMutation builder.
func (m *BusinessMutation) Where(ps ...predicate.Business) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Business, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Business).
func (m *BusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, business.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, business.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, business.FieldDeletedAt)
	}
	if m.name1 != nil {
		fields = append(fields, business.FieldName1)
	}
	if m.name2 != nil {
		fields = append(fields, business.FieldName2)
	}
	if m.alias != nil {
		fields = append(fields, business.FieldAlias)
	}
	if m.telephone != nil {
		fields = append(fields, business.FieldTelephone)
	}
	if m.email != nil {
		fields = append(fields, business.FieldEmail)
	}
	if m.website != nil {
		fields = append(fields, business.FieldWebsite)
	}
	if m.comment != nil {
		fields = append(fields, business.FieldComment)
	}
	if m.active != nil {
		fields = append(fields, business.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case business.FieldCreatedAt:
		return m.CreatedAt()
	case business.FieldUpdatedAt:
		return m.UpdatedAt()
	case business.FieldDeletedAt:
		return m.DeletedAt()
	case business.FieldName1:
		return m.Name1()
	case business.FieldName2:
		return m.Name2()
	case business.FieldAlias:
		return m.Alias()
	case business.FieldTelephone:
		return m.Telephone()
	case business.FieldEmail:
		return m.Email()
	case business.FieldWebsite:
		return m.Website()
	case business.FieldComment:
		return m.Comment()
	case business.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case business.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case business.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case business.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case business.FieldName1:
		return m.OldName1(ctx)
	case business.FieldName2:
		return m.OldName2(ctx)
	case business.FieldAlias:
		return m.OldAlias(ctx)
	case business.FieldTelephone:
		return m.OldTelephone(ctx)
	case business.FieldEmail:
		return m.OldEmail(ctx)
	case business.FieldWebsite:
		return m.OldWebsite(ctx)
	case business.FieldComment:
		return m.OldComment(ctx)
	case business.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown Business field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case business.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case business.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case business.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case business.FieldName1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName1(v)
		return nil
	case business.FieldName2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName2(v)
		return nil
	case business.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case business.FieldTelephone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case business.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case business.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case business.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case business.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Business numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(business.FieldDeletedAt) {
		fields = append(fields, business.FieldDeletedAt)
	}
	if m.FieldCleared(business.FieldName2) {
		fields = append(fields, business.FieldName2)
	}
	if m.FieldCleared(business.FieldTelephone) {
		fields = append(fields, business.FieldTelephone)
	}
	if m.FieldCleared(business.FieldEmail) {
		fields = append(fields, business.FieldEmail)
	}
	if m.FieldCleared(business.FieldWebsite) {
		fields = append(fields, business.FieldWebsite)
	}
	if m.FieldCleared(business.FieldComment) {
		fields = append(fields, business.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessMutation) ClearField(name string) error {
	switch name {
	case business.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case business.FieldName2:
		m.ClearName2()
		return nil
	case business.FieldTelephone:
		m.ClearTelephone()
		return nil
	case business.FieldEmail:
		m.ClearEmail()
		return nil
	case business.FieldWebsite:
		m.ClearWebsite()
		return nil
	case business.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown Business nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessMutation) ResetField(name string) error {
	switch name {
	case business.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case business.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case business.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case business.FieldName1:
		m.ResetName1()
		return nil
	case business.FieldName2:
		m.ResetName2()
		return nil
	case business.FieldAlias:
		m.ResetAlias()
		return nil
	case business.FieldTelephone:
		m.ResetTelephone()
		return nil
	case business.FieldEmail:
		m.ResetEmail()
		return nil
	case business.FieldWebsite:
		m.ResetWebsite()
		return nil
	case business.FieldComment:
		m.ResetComment()
		return nil
	case business.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.addresses != nil {
		edges = append(edges, business.EdgeAddresses)
	}
	if m.tags != nil {
		edges = append(edges, business.EdgeTags)
	}
	if m.users != nil {
		edges = append(edges, business.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedaddresses != nil {
		edges = append(edges, business.EdgeAddresses)
	}
	if m.removedtags != nil {
		edges = append(edges, business.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedaddresses {
		edges = append(edges, business.EdgeAddresses)
	}
	if m.clearedtags {
		edges = append(edges, business.EdgeTags)
	}
	if m.clearedusers {
		edges = append(edges, business.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case business.EdgeAddresses:
		return m.clearedaddresses
	case business.EdgeTags:
		return m.clearedtags
	case business.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessMutation) ClearEdge(name string) error {
	switch name {
	case business.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Business unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessMutation) ResetEdge(name string) error {
	switch name {
	case business.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case business.EdgeTags:
		m.ResetTags()
		return nil
	case business.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Business edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	name            *string
	comment         *string
	clearedFields   map[string]struct{}
	business        map[uuid.UUID]struct{}
	removedbusiness map[uuid.UUID]struct{}
	clearedbusiness bool
	user            map[uuid.UUID]struct{}
	removeduser     map[uuid.UUID]struct{}
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Tag, error)
	predicates      []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tag.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetComment sets the "comment" field.
func (m *TagMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *TagMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *TagMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[tag.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *TagMutation) CommentCleared() bool {
	_, ok := m.clearedFields[tag.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *TagMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, tag.FieldComment)
}

// AddBusinesIDs adds the "business" edge to the Business entity by ids.
func (m *TagMutation) AddBusinesIDs(ids ...uuid.UUID) {
	if m.business == nil {
		m.business = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.business[ids[i]] = struct{}{}
	}
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *TagMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *TagMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// RemoveBusinesIDs removes the "business" edge to the Business entity by IDs.
func (m *TagMutation) RemoveBusinesIDs(ids ...uuid.UUID) {
	if m.removedbusiness == nil {
		m.removedbusiness = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.business, ids[i])
		m.removedbusiness[ids[i]] = struct{}{}
	}
}

// RemovedBusiness returns the removed IDs of the "business" edge to the Business entity.
func (m *TagMutation) RemovedBusinessIDs() (ids []uuid.UUID) {
	for id := range m.removedbusiness {
		ids = append(ids, id)
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
func (m *TagMutation) BusinessIDs() (ids []uuid.UUID) {
	for id := range m.business {
		ids = append(ids, id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *TagMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
	m.removedbusiness = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *TagMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.user == nil {
		m.user = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *TagMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TagMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *TagMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removeduser == nil {
		m.removeduser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *TagMutation) RemovedUserIDs() (ids []uuid.UUID) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *TagMutation) UserIDs() (ids []uuid.UUID) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TagMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tag.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.comment != nil {
		fields = append(fields, tag.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldDeletedAt:
		return m.DeletedAt()
	case tag.FieldName:
		return m.Name()
	case tag.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDeletedAt) {
		fields = append(fields, tag.FieldDeletedAt)
	}
	if m.FieldCleared(tag.FieldComment) {
		fields = append(fields, tag.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tag.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business != nil {
		edges = append(edges, tag.EdgeBusiness)
	}
	if m.user != nil {
		edges = append(edges, tag.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeBusiness:
		ids := make([]ent.Value, 0, len(m.business))
		for id := range m.business {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbusiness != nil {
		edges = append(edges, tag.EdgeBusiness)
	}
	if m.removeduser != nil {
		edges = append(edges, tag.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeBusiness:
		ids := make([]ent.Value, 0, len(m.removedbusiness))
		for id := range m.removedbusiness {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness {
		edges = append(edges, tag.EdgeBusiness)
	}
	if m.cleareduser {
		edges = append(edges, tag.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeBusiness:
		return m.clearedbusiness
	case tag.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case tag.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TimetableMutation represents an operation that mutates the Timetable nodes in the graph.
type TimetableMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	_type                    *timetable.Type
	datetime_from            *time.Time
	datetime_to              *time.Time
	time_whole_day           *bool
	comment                  *string
	availability_by_phone    *string
	availability_by_email    *string
	availability_by_sms      *string
	availability_by_whatsapp *string
	clearedFields            map[string]struct{}
	address                  *uuid.UUID
	clearedaddress           bool
	users_on_duty            map[uuid.UUID]struct{}
	removedusers_on_duty     map[uuid.UUID]struct{}
	clearedusers_on_duty     bool
	done                     bool
	oldValue                 func(context.Context) (*Timetable, error)
	predicates               []predicate.Timetable
}

var _ ent.Mutation = (*TimetableMutation)(nil)

// timetableOption allows management of the mutation configuration using functional options.
type timetableOption func(*TimetableMutation)

// newTimetableMutation creates new mutation for the Timetable entity.
func newTimetableMutation(c config, op Op, opts ...timetableOption) *TimetableMutation {
	m := &TimetableMutation{
		config:        c,
		op:            op,
		typ:           TypeTimetable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimetableID sets the ID field of the mutation.
func withTimetableID(id uuid.UUID) timetableOption {
	return func(m *TimetableMutation) {
		var (
			err   error
			once  sync.Once
			value *Timetable
		)
		m.oldValue = func(ctx context.Context) (*Timetable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Timetable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimetable sets the old Timetable of the mutation.
func withTimetable(node *Timetable) timetableOption {
	return func(m *TimetableMutation) {
		m.oldValue = func(context.Context) (*Timetable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimetableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimetableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Timetable entities.
func (m *TimetableMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimetableMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimetableMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Timetable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TimetableMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimetableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimetableMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TimetableMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TimetableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TimetableMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TimetableMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TimetableMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TimetableMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[timetable.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TimetableMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[timetable.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TimetableMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, timetable.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *TimetableMutation) SetType(t timetable.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TimetableMutation) GetType() (r timetable.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldType(ctx context.Context) (v timetable.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TimetableMutation) ResetType() {
	m._type = nil
}

// SetDatetimeFrom sets the "datetime_from" field.
func (m *TimetableMutation) SetDatetimeFrom(t time.Time) {
	m.datetime_from = &t
}

// DatetimeFrom returns the value of the "datetime_from" field in the mutation.
func (m *TimetableMutation) DatetimeFrom() (r time.Time, exists bool) {
	v := m.datetime_from
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetimeFrom returns the old "datetime_from" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldDatetimeFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatetimeFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatetimeFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetimeFrom: %w", err)
	}
	return oldValue.DatetimeFrom, nil
}

// ClearDatetimeFrom clears the value of the "datetime_from" field.
func (m *TimetableMutation) ClearDatetimeFrom() {
	m.datetime_from = nil
	m.clearedFields[timetable.FieldDatetimeFrom] = struct{}{}
}

// DatetimeFromCleared returns if the "datetime_from" field was cleared in this mutation.
func (m *TimetableMutation) DatetimeFromCleared() bool {
	_, ok := m.clearedFields[timetable.FieldDatetimeFrom]
	return ok
}

// ResetDatetimeFrom resets all changes to the "datetime_from" field.
func (m *TimetableMutation) ResetDatetimeFrom() {
	m.datetime_from = nil
	delete(m.clearedFields, timetable.FieldDatetimeFrom)
}

// SetDatetimeTo sets the "datetime_to" field.
func (m *TimetableMutation) SetDatetimeTo(t time.Time) {
	m.datetime_to = &t
}

// DatetimeTo returns the value of the "datetime_to" field in the mutation.
func (m *TimetableMutation) DatetimeTo() (r time.Time, exists bool) {
	v := m.datetime_to
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetimeTo returns the old "datetime_to" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldDatetimeTo(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatetimeTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatetimeTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetimeTo: %w", err)
	}
	return oldValue.DatetimeTo, nil
}

// ClearDatetimeTo clears the value of the "datetime_to" field.
func (m *TimetableMutation) ClearDatetimeTo() {
	m.datetime_to = nil
	m.clearedFields[timetable.FieldDatetimeTo] = struct{}{}
}

// DatetimeToCleared returns if the "datetime_to" field was cleared in this mutation.
func (m *TimetableMutation) DatetimeToCleared() bool {
	_, ok := m.clearedFields[timetable.FieldDatetimeTo]
	return ok
}

// ResetDatetimeTo resets all changes to the "datetime_to" field.
func (m *TimetableMutation) ResetDatetimeTo() {
	m.datetime_to = nil
	delete(m.clearedFields, timetable.FieldDatetimeTo)
}

// SetTimeWholeDay sets the "time_whole_day" field.
func (m *TimetableMutation) SetTimeWholeDay(b bool) {
	m.time_whole_day = &b
}

// TimeWholeDay returns the value of the "time_whole_day" field in the mutation.
func (m *TimetableMutation) TimeWholeDay() (r bool, exists bool) {
	v := m.time_whole_day
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeWholeDay returns the old "time_whole_day" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldTimeWholeDay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeWholeDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeWholeDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeWholeDay: %w", err)
	}
	return oldValue.TimeWholeDay, nil
}

// ResetTimeWholeDay resets all changes to the "time_whole_day" field.
func (m *TimetableMutation) ResetTimeWholeDay() {
	m.time_whole_day = nil
}

// SetComment sets the "comment" field.
func (m *TimetableMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *TimetableMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *TimetableMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[timetable.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *TimetableMutation) CommentCleared() bool {
	_, ok := m.clearedFields[timetable.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *TimetableMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, timetable.FieldComment)
}

// SetAvailabilityByPhone sets the "availability_by_phone" field.
func (m *TimetableMutation) SetAvailabilityByPhone(s string) {
	m.availability_by_phone = &s
}

// AvailabilityByPhone returns the value of the "availability_by_phone" field in the mutation.
func (m *TimetableMutation) AvailabilityByPhone() (r string, exists bool) {
	v := m.availability_by_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailabilityByPhone returns the old "availability_by_phone" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldAvailabilityByPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailabilityByPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailabilityByPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailabilityByPhone: %w", err)
	}
	return oldValue.AvailabilityByPhone, nil
}

// ClearAvailabilityByPhone clears the value of the "availability_by_phone" field.
func (m *TimetableMutation) ClearAvailabilityByPhone() {
	m.availability_by_phone = nil
	m.clearedFields[timetable.FieldAvailabilityByPhone] = struct{}{}
}

// AvailabilityByPhoneCleared returns if the "availability_by_phone" field was cleared in this mutation.
func (m *TimetableMutation) AvailabilityByPhoneCleared() bool {
	_, ok := m.clearedFields[timetable.FieldAvailabilityByPhone]
	return ok
}

// ResetAvailabilityByPhone resets all changes to the "availability_by_phone" field.
func (m *TimetableMutation) ResetAvailabilityByPhone() {
	m.availability_by_phone = nil
	delete(m.clearedFields, timetable.FieldAvailabilityByPhone)
}

// SetAvailabilityByEmail sets the "availability_by_email" field.
func (m *TimetableMutation) SetAvailabilityByEmail(s string) {
	m.availability_by_email = &s
}

// AvailabilityByEmail returns the value of the "availability_by_email" field in the mutation.
func (m *TimetableMutation) AvailabilityByEmail() (r string, exists bool) {
	v := m.availability_by_email
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailabilityByEmail returns the old "availability_by_email" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldAvailabilityByEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailabilityByEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailabilityByEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailabilityByEmail: %w", err)
	}
	return oldValue.AvailabilityByEmail, nil
}

// ClearAvailabilityByEmail clears the value of the "availability_by_email" field.
func (m *TimetableMutation) ClearAvailabilityByEmail() {
	m.availability_by_email = nil
	m.clearedFields[timetable.FieldAvailabilityByEmail] = struct{}{}
}

// AvailabilityByEmailCleared returns if the "availability_by_email" field was cleared in this mutation.
func (m *TimetableMutation) AvailabilityByEmailCleared() bool {
	_, ok := m.clearedFields[timetable.FieldAvailabilityByEmail]
	return ok
}

// ResetAvailabilityByEmail resets all changes to the "availability_by_email" field.
func (m *TimetableMutation) ResetAvailabilityByEmail() {
	m.availability_by_email = nil
	delete(m.clearedFields, timetable.FieldAvailabilityByEmail)
}

// SetAvailabilityBySms sets the "availability_by_sms" field.
func (m *TimetableMutation) SetAvailabilityBySms(s string) {
	m.availability_by_sms = &s
}

// AvailabilityBySms returns the value of the "availability_by_sms" field in the mutation.
func (m *TimetableMutation) AvailabilityBySms() (r string, exists bool) {
	v := m.availability_by_sms
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailabilityBySms returns the old "availability_by_sms" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldAvailabilityBySms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailabilityBySms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailabilityBySms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailabilityBySms: %w", err)
	}
	return oldValue.AvailabilityBySms, nil
}

// ClearAvailabilityBySms clears the value of the "availability_by_sms" field.
func (m *TimetableMutation) ClearAvailabilityBySms() {
	m.availability_by_sms = nil
	m.clearedFields[timetable.FieldAvailabilityBySms] = struct{}{}
}

// AvailabilityBySmsCleared returns if the "availability_by_sms" field was cleared in this mutation.
func (m *TimetableMutation) AvailabilityBySmsCleared() bool {
	_, ok := m.clearedFields[timetable.FieldAvailabilityBySms]
	return ok
}

// ResetAvailabilityBySms resets all changes to the "availability_by_sms" field.
func (m *TimetableMutation) ResetAvailabilityBySms() {
	m.availability_by_sms = nil
	delete(m.clearedFields, timetable.FieldAvailabilityBySms)
}

// SetAvailabilityByWhatsapp sets the "availability_by_whatsapp" field.
func (m *TimetableMutation) SetAvailabilityByWhatsapp(s string) {
	m.availability_by_whatsapp = &s
}

// AvailabilityByWhatsapp returns the value of the "availability_by_whatsapp" field in the mutation.
func (m *TimetableMutation) AvailabilityByWhatsapp() (r string, exists bool) {
	v := m.availability_by_whatsapp
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailabilityByWhatsapp returns the old "availability_by_whatsapp" field's value of the Timetable entity.
// If the Timetable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimetableMutation) OldAvailabilityByWhatsapp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailabilityByWhatsapp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailabilityByWhatsapp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailabilityByWhatsapp: %w", err)
	}
	return oldValue.AvailabilityByWhatsapp, nil
}

// ClearAvailabilityByWhatsapp clears the value of the "availability_by_whatsapp" field.
func (m *TimetableMutation) ClearAvailabilityByWhatsapp() {
	m.availability_by_whatsapp = nil
	m.clearedFields[timetable.FieldAvailabilityByWhatsapp] = struct{}{}
}

// AvailabilityByWhatsappCleared returns if the "availability_by_whatsapp" field was cleared in this mutation.
func (m *TimetableMutation) AvailabilityByWhatsappCleared() bool {
	_, ok := m.clearedFields[timetable.FieldAvailabilityByWhatsapp]
	return ok
}

// ResetAvailabilityByWhatsapp resets all changes to the "availability_by_whatsapp" field.
func (m *TimetableMutation) ResetAvailabilityByWhatsapp() {
	m.availability_by_whatsapp = nil
	delete(m.clearedFields, timetable.FieldAvailabilityByWhatsapp)
}

// SetAddressID sets the "address" edge to the Address entity by id.
func (m *TimetableMutation) SetAddressID(id uuid.UUID) {
	m.address = &id
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *TimetableMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *TimetableMutation) AddressCleared() bool {
	return m.clearedaddress
}

// AddressID returns the "address" edge ID in the mutation.
func (m *TimetableMutation) AddressID() (id uuid.UUID, exists bool) {
	if m.address != nil {
		return *m.address, true
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *TimetableMutation) AddressIDs() (ids []uuid.UUID) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *TimetableMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// AddUsersOnDutyIDs adds the "users_on_duty" edge to the User entity by ids.
func (m *TimetableMutation) AddUsersOnDutyIDs(ids ...uuid.UUID) {
	if m.users_on_duty == nil {
		m.users_on_duty = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users_on_duty[ids[i]] = struct{}{}
	}
}

// ClearUsersOnDuty clears the "users_on_duty" edge to the User entity.
func (m *TimetableMutation) ClearUsersOnDuty() {
	m.clearedusers_on_duty = true
}

// UsersOnDutyCleared reports if the "users_on_duty" edge to the User entity was cleared.
func (m *TimetableMutation) UsersOnDutyCleared() bool {
	return m.clearedusers_on_duty
}

// RemoveUsersOnDutyIDs removes the "users_on_duty" edge to the User entity by IDs.
func (m *TimetableMutation) RemoveUsersOnDutyIDs(ids ...uuid.UUID) {
	if m.removedusers_on_duty == nil {
		m.removedusers_on_duty = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users_on_duty, ids[i])
		m.removedusers_on_duty[ids[i]] = struct{}{}
	}
}

// RemovedUsersOnDuty returns the removed IDs of the "users_on_duty" edge to the User entity.
func (m *TimetableMutation) RemovedUsersOnDutyIDs() (ids []uuid.UUID) {
	for id := range m.removedusers_on_duty {
		ids = append(ids, id)
	}
	return
}

// UsersOnDutyIDs returns the "users_on_duty" edge IDs in the mutation.
func (m *TimetableMutation) UsersOnDutyIDs() (ids []uuid.UUID) {
	for id := range m.users_on_duty {
		ids = append(ids, id)
	}
	return
}

// ResetUsersOnDuty resets all changes to the "users_on_duty" edge.
func (m *TimetableMutation) ResetUsersOnDuty() {
	m.users_on_duty = nil
	m.clearedusers_on_duty = false
	m.removedusers_on_duty = nil
}

// Where appends a list predicates to the TimetableMutation builder.
func (m *TimetableMutation) Where(ps ...predicate.Timetable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimetableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimetableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Timetable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimetableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimetableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Timetable).
func (m *TimetableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimetableMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, timetable.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, timetable.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, timetable.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, timetable.FieldType)
	}
	if m.datetime_from != nil {
		fields = append(fields, timetable.FieldDatetimeFrom)
	}
	if m.datetime_to != nil {
		fields = append(fields, timetable.FieldDatetimeTo)
	}
	if m.time_whole_day != nil {
		fields = append(fields, timetable.FieldTimeWholeDay)
	}
	if m.comment != nil {
		fields = append(fields, timetable.FieldComment)
	}
	if m.availability_by_phone != nil {
		fields = append(fields, timetable.FieldAvailabilityByPhone)
	}
	if m.availability_by_email != nil {
		fields = append(fields, timetable.FieldAvailabilityByEmail)
	}
	if m.availability_by_sms != nil {
		fields = append(fields, timetable.FieldAvailabilityBySms)
	}
	if m.availability_by_whatsapp != nil {
		fields = append(fields, timetable.FieldAvailabilityByWhatsapp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimetableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timetable.FieldCreatedAt:
		return m.CreatedAt()
	case timetable.FieldUpdatedAt:
		return m.UpdatedAt()
	case timetable.FieldDeletedAt:
		return m.DeletedAt()
	case timetable.FieldType:
		return m.GetType()
	case timetable.FieldDatetimeFrom:
		return m.DatetimeFrom()
	case timetable.FieldDatetimeTo:
		return m.DatetimeTo()
	case timetable.FieldTimeWholeDay:
		return m.TimeWholeDay()
	case timetable.FieldComment:
		return m.Comment()
	case timetable.FieldAvailabilityByPhone:
		return m.AvailabilityByPhone()
	case timetable.FieldAvailabilityByEmail:
		return m.AvailabilityByEmail()
	case timetable.FieldAvailabilityBySms:
		return m.AvailabilityBySms()
	case timetable.FieldAvailabilityByWhatsapp:
		return m.AvailabilityByWhatsapp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimetableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timetable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case timetable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case timetable.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case timetable.FieldType:
		return m.OldType(ctx)
	case timetable.FieldDatetimeFrom:
		return m.OldDatetimeFrom(ctx)
	case timetable.FieldDatetimeTo:
		return m.OldDatetimeTo(ctx)
	case timetable.FieldTimeWholeDay:
		return m.OldTimeWholeDay(ctx)
	case timetable.FieldComment:
		return m.OldComment(ctx)
	case timetable.FieldAvailabilityByPhone:
		return m.OldAvailabilityByPhone(ctx)
	case timetable.FieldAvailabilityByEmail:
		return m.OldAvailabilityByEmail(ctx)
	case timetable.FieldAvailabilityBySms:
		return m.OldAvailabilityBySms(ctx)
	case timetable.FieldAvailabilityByWhatsapp:
		return m.OldAvailabilityByWhatsapp(ctx)
	}
	return nil, fmt.Errorf("unknown Timetable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimetableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timetable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case timetable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case timetable.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case timetable.FieldType:
		v, ok := value.(timetable.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case timetable.FieldDatetimeFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetimeFrom(v)
		return nil
	case timetable.FieldDatetimeTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetimeTo(v)
		return nil
	case timetable.FieldTimeWholeDay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeWholeDay(v)
		return nil
	case timetable.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case timetable.FieldAvailabilityByPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailabilityByPhone(v)
		return nil
	case timetable.FieldAvailabilityByEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailabilityByEmail(v)
		return nil
	case timetable.FieldAvailabilityBySms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailabilityBySms(v)
		return nil
	case timetable.FieldAvailabilityByWhatsapp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailabilityByWhatsapp(v)
		return nil
	}
	return fmt.Errorf("unknown Timetable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimetableMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimetableMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimetableMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Timetable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimetableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timetable.FieldDeletedAt) {
		fields = append(fields, timetable.FieldDeletedAt)
	}
	if m.FieldCleared(timetable.FieldDatetimeFrom) {
		fields = append(fields, timetable.FieldDatetimeFrom)
	}
	if m.FieldCleared(timetable.FieldDatetimeTo) {
		fields = append(fields, timetable.FieldDatetimeTo)
	}
	if m.FieldCleared(timetable.FieldComment) {
		fields = append(fields, timetable.FieldComment)
	}
	if m.FieldCleared(timetable.FieldAvailabilityByPhone) {
		fields = append(fields, timetable.FieldAvailabilityByPhone)
	}
	if m.FieldCleared(timetable.FieldAvailabilityByEmail) {
		fields = append(fields, timetable.FieldAvailabilityByEmail)
	}
	if m.FieldCleared(timetable.FieldAvailabilityBySms) {
		fields = append(fields, timetable.FieldAvailabilityBySms)
	}
	if m.FieldCleared(timetable.FieldAvailabilityByWhatsapp) {
		fields = append(fields, timetable.FieldAvailabilityByWhatsapp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimetableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimetableMutation) ClearField(name string) error {
	switch name {
	case timetable.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case timetable.FieldDatetimeFrom:
		m.ClearDatetimeFrom()
		return nil
	case timetable.FieldDatetimeTo:
		m.ClearDatetimeTo()
		return nil
	case timetable.FieldComment:
		m.ClearComment()
		return nil
	case timetable.FieldAvailabilityByPhone:
		m.ClearAvailabilityByPhone()
		return nil
	case timetable.FieldAvailabilityByEmail:
		m.ClearAvailabilityByEmail()
		return nil
	case timetable.FieldAvailabilityBySms:
		m.ClearAvailabilityBySms()
		return nil
	case timetable.FieldAvailabilityByWhatsapp:
		m.ClearAvailabilityByWhatsapp()
		return nil
	}
	return fmt.Errorf("unknown Timetable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimetableMutation) ResetField(name string) error {
	switch name {
	case timetable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case timetable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case timetable.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case timetable.FieldType:
		m.ResetType()
		return nil
	case timetable.FieldDatetimeFrom:
		m.ResetDatetimeFrom()
		return nil
	case timetable.FieldDatetimeTo:
		m.ResetDatetimeTo()
		return nil
	case timetable.FieldTimeWholeDay:
		m.ResetTimeWholeDay()
		return nil
	case timetable.FieldComment:
		m.ResetComment()
		return nil
	case timetable.FieldAvailabilityByPhone:
		m.ResetAvailabilityByPhone()
		return nil
	case timetable.FieldAvailabilityByEmail:
		m.ResetAvailabilityByEmail()
		return nil
	case timetable.FieldAvailabilityBySms:
		m.ResetAvailabilityBySms()
		return nil
	case timetable.FieldAvailabilityByWhatsapp:
		m.ResetAvailabilityByWhatsapp()
		return nil
	}
	return fmt.Errorf("unknown Timetable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimetableMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.address != nil {
		edges = append(edges, timetable.EdgeAddress)
	}
	if m.users_on_duty != nil {
		edges = append(edges, timetable.EdgeUsersOnDuty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimetableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timetable.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	case timetable.EdgeUsersOnDuty:
		ids := make([]ent.Value, 0, len(m.users_on_duty))
		for id := range m.users_on_duty {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimetableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers_on_duty != nil {
		edges = append(edges, timetable.EdgeUsersOnDuty)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimetableMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case timetable.EdgeUsersOnDuty:
		ids := make([]ent.Value, 0, len(m.removedusers_on_duty))
		for id := range m.removedusers_on_duty {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimetableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaddress {
		edges = append(edges, timetable.EdgeAddress)
	}
	if m.clearedusers_on_duty {
		edges = append(edges, timetable.EdgeUsersOnDuty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimetableMutation) EdgeCleared(name string) bool {
	switch name {
	case timetable.EdgeAddress:
		return m.clearedaddress
	case timetable.EdgeUsersOnDuty:
		return m.clearedusers_on_duty
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimetableMutation) ClearEdge(name string) error {
	switch name {
	case timetable.EdgeAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Timetable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimetableMutation) ResetEdge(name string) error {
	switch name {
	case timetable.EdgeAddress:
		m.ResetAddress()
		return nil
	case timetable.EdgeUsersOnDuty:
		m.ResetUsersOnDuty()
		return nil
	}
	return fmt.Errorf("unknown Timetable edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	surname           *string
	firstname         *string
	title             *string
	email             *string
	passwordhash      *string
	comment           *string
	active            *bool
	role              *int
	addrole           *int
	clearedFields     map[string]struct{}
	businesses        map[uuid.UUID]struct{}
	removedbusinesses map[uuid.UUID]struct{}
	clearedbusinesses bool
	tags              map[uuid.UUID]struct{}
	removedtags       map[uuid.UUID]struct{}
	clearedtags       bool
	timetable         map[uuid.UUID]struct{}
	removedtimetable  map[uuid.UUID]struct{}
	clearedtimetable  bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetSurname sets the "surname" field.
func (m *UserMutation) SetSurname(s string) {
	m.surname = &s
}

// Surname returns the value of the "surname" field in the mutation.
func (m *UserMutation) Surname() (r string, exists bool) {
	v := m.surname
	if v == nil {
		return
	}
	return *v, true
}

// OldSurname returns the old "surname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSurname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurname: %w", err)
	}
	return oldValue.Surname, nil
}

// ResetSurname resets all changes to the "surname" field.
func (m *UserMutation) ResetSurname() {
	m.surname = nil
}

// SetFirstname sets the "firstname" field.
func (m *UserMutation) SetFirstname(s string) {
	m.firstname = &s
}

// Firstname returns the value of the "firstname" field in the mutation.
func (m *UserMutation) Firstname() (r string, exists bool) {
	v := m.firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstname returns the old "firstname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstname: %w", err)
	}
	return oldValue.Firstname, nil
}

// ResetFirstname resets all changes to the "firstname" field.
func (m *UserMutation) ResetFirstname() {
	m.firstname = nil
}

// SetTitle sets the "title" field.
func (m *UserMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UserMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *UserMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[user.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *UserMutation) TitleCleared() bool {
	_, ok := m.clearedFields[user.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *UserMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, user.FieldTitle)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordhash sets the "passwordhash" field.
func (m *UserMutation) SetPasswordhash(s string) {
	m.passwordhash = &s
}

// Passwordhash returns the value of the "passwordhash" field in the mutation.
func (m *UserMutation) Passwordhash() (r string, exists bool) {
	v := m.passwordhash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordhash returns the old "passwordhash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordhash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordhash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordhash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordhash: %w", err)
	}
	return oldValue.Passwordhash, nil
}

// ClearPasswordhash clears the value of the "passwordhash" field.
func (m *UserMutation) ClearPasswordhash() {
	m.passwordhash = nil
	m.clearedFields[user.FieldPasswordhash] = struct{}{}
}

// PasswordhashCleared returns if the "passwordhash" field was cleared in this mutation.
func (m *UserMutation) PasswordhashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordhash]
	return ok
}

// ResetPasswordhash resets all changes to the "passwordhash" field.
func (m *UserMutation) ResetPasswordhash() {
	m.passwordhash = nil
	delete(m.clearedFields, user.FieldPasswordhash)
}

// SetComment sets the "comment" field.
func (m *UserMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *UserMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *UserMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[user.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *UserMutation) CommentCleared() bool {
	_, ok := m.clearedFields[user.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *UserMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, user.FieldComment)
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(i int) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *UserMutation) AddRole(i int) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *UserMutation) AddedRole() (r int, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// AddBusinessIDs adds the "businesses" edge to the Business entity by ids.
func (m *UserMutation) AddBusinessIDs(ids ...uuid.UUID) {
	if m.businesses == nil {
		m.businesses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.businesses[ids[i]] = struct{}{}
	}
}

// ClearBusinesses clears the "businesses" edge to the Business entity.
func (m *UserMutation) ClearBusinesses() {
	m.clearedbusinesses = true
}

// BusinessesCleared reports if the "businesses" edge to the Business entity was cleared.
func (m *UserMutation) BusinessesCleared() bool {
	return m.clearedbusinesses
}

// RemoveBusinessIDs removes the "businesses" edge to the Business entity by IDs.
func (m *UserMutation) RemoveBusinessIDs(ids ...uuid.UUID) {
	if m.removedbusinesses == nil {
		m.removedbusinesses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.businesses, ids[i])
		m.removedbusinesses[ids[i]] = struct{}{}
	}
}

// RemovedBusinesses returns the removed IDs of the "businesses" edge to the Business entity.
func (m *UserMutation) RemovedBusinessesIDs() (ids []uuid.UUID) {
	for id := range m.removedbusinesses {
		ids = append(ids, id)
	}
	return
}

// BusinessesIDs returns the "businesses" edge IDs in the mutation.
func (m *UserMutation) BusinessesIDs() (ids []uuid.UUID) {
	for id := range m.businesses {
		ids = append(ids, id)
	}
	return
}

// ResetBusinesses resets all changes to the "businesses" edge.
func (m *UserMutation) ResetBusinesses() {
	m.businesses = nil
	m.clearedbusinesses = false
	m.removedbusinesses = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *UserMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *UserMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *UserMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *UserMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *UserMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *UserMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *UserMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddTimetableIDs adds the "timetable" edge to the Timetable entity by ids.
func (m *UserMutation) AddTimetableIDs(ids ...uuid.UUID) {
	if m.timetable == nil {
		m.timetable = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.timetable[ids[i]] = struct{}{}
	}
}

// ClearTimetable clears the "timetable" edge to the Timetable entity.
func (m *UserMutation) ClearTimetable() {
	m.clearedtimetable = true
}

// TimetableCleared reports if the "timetable" edge to the Timetable entity was cleared.
func (m *UserMutation) TimetableCleared() bool {
	return m.clearedtimetable
}

// RemoveTimetableIDs removes the "timetable" edge to the Timetable entity by IDs.
func (m *UserMutation) RemoveTimetableIDs(ids ...uuid.UUID) {
	if m.removedtimetable == nil {
		m.removedtimetable = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.timetable, ids[i])
		m.removedtimetable[ids[i]] = struct{}{}
	}
}

// RemovedTimetable returns the removed IDs of the "timetable" edge to the Timetable entity.
func (m *UserMutation) RemovedTimetableIDs() (ids []uuid.UUID) {
	for id := range m.removedtimetable {
		ids = append(ids, id)
	}
	return
}

// TimetableIDs returns the "timetable" edge IDs in the mutation.
func (m *UserMutation) TimetableIDs() (ids []uuid.UUID) {
	for id := range m.timetable {
		ids = append(ids, id)
	}
	return
}

// ResetTimetable resets all changes to the "timetable" edge.
func (m *UserMutation) ResetTimetable() {
	m.timetable = nil
	m.clearedtimetable = false
	m.removedtimetable = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.surname != nil {
		fields = append(fields, user.FieldSurname)
	}
	if m.firstname != nil {
		fields = append(fields, user.FieldFirstname)
	}
	if m.title != nil {
		fields = append(fields, user.FieldTitle)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.passwordhash != nil {
		fields = append(fields, user.FieldPasswordhash)
	}
	if m.comment != nil {
		fields = append(fields, user.FieldComment)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldSurname:
		return m.Surname()
	case user.FieldFirstname:
		return m.Firstname()
	case user.FieldTitle:
		return m.Title()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordhash:
		return m.Passwordhash()
	case user.FieldComment:
		return m.Comment()
	case user.FieldActive:
		return m.Active()
	case user.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldSurname:
		return m.OldSurname(ctx)
	case user.FieldFirstname:
		return m.OldFirstname(ctx)
	case user.FieldTitle:
		return m.OldTitle(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordhash:
		return m.OldPasswordhash(ctx)
	case user.FieldComment:
		return m.OldComment(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldSurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurname(v)
		return nil
	case user.FieldFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstname(v)
		return nil
	case user.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordhash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordhash(v)
		return nil
	case user.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrole != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldTitle) {
		fields = append(fields, user.FieldTitle)
	}
	if m.FieldCleared(user.FieldPasswordhash) {
		fields = append(fields, user.FieldPasswordhash)
	}
	if m.FieldCleared(user.FieldComment) {
		fields = append(fields, user.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldTitle:
		m.ClearTitle()
		return nil
	case user.FieldPasswordhash:
		m.ClearPasswordhash()
		return nil
	case user.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldSurname:
		m.ResetSurname()
		return nil
	case user.FieldFirstname:
		m.ResetFirstname()
		return nil
	case user.FieldTitle:
		m.ResetTitle()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordhash:
		m.ResetPasswordhash()
		return nil
	case user.FieldComment:
		m.ResetComment()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.businesses != nil {
		edges = append(edges, user.EdgeBusinesses)
	}
	if m.tags != nil {
		edges = append(edges, user.EdgeTags)
	}
	if m.timetable != nil {
		edges = append(edges, user.EdgeTimetable)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBusinesses:
		ids := make([]ent.Value, 0, len(m.businesses))
		for id := range m.businesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTimetable:
		ids := make([]ent.Value, 0, len(m.timetable))
		for id := range m.timetable {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbusinesses != nil {
		edges = append(edges, user.EdgeBusinesses)
	}
	if m.removedtags != nil {
		edges = append(edges, user.EdgeTags)
	}
	if m.removedtimetable != nil {
		edges = append(edges, user.EdgeTimetable)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBusinesses:
		ids := make([]ent.Value, 0, len(m.removedbusinesses))
		for id := range m.removedbusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTimetable:
		ids := make([]ent.Value, 0, len(m.removedtimetable))
		for id := range m.removedtimetable {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusinesses {
		edges = append(edges, user.EdgeBusinesses)
	}
	if m.clearedtags {
		edges = append(edges, user.EdgeTags)
	}
	if m.clearedtimetable {
		edges = append(edges, user.EdgeTimetable)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBusinesses:
		return m.clearedbusinesses
	case user.EdgeTags:
		return m.clearedtags
	case user.EdgeTimetable:
		return m.clearedtimetable
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBusinesses:
		m.ResetBusinesses()
		return nil
	case user.EdgeTags:
		m.ResetTags()
		return nil
	case user.EdgeTimetable:
		m.ResetTimetable()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
