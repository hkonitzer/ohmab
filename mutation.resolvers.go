package OHMAB

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.33

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/hkonitzer/ohmab/ent"
	"github.com/hkonitzer/ohmab/ent/user"
	"github.com/hkonitzer/ohmab/internal/pkg/common/log"
	"github.com/hkonitzer/ohmab/internal/pkg/privacy"
)

// CreateBusiness is the resolver for the createBusiness field.
func (r *mutationResolver) CreateBusiness(ctx context.Context, input ent.CreateBusinessInput) (*ent.Business, error) {
	logger := log.GetLoggerInstance()
	uv, _ := privacy.FromContext(ctx)
	uid, err := uuid.Parse(uv.GetUserID())
	if err != nil {
		logger.Err(err).Msgf("Error parsing UUID from UserViewer: %v", uv.GetUserID())
	}
	u, err := r.client.User.Query().Where(user.IDEQ(uid)).Only(ctx)
	if err != nil {
		logger.Err(err).Msgf("Error querying user with ID: '%v'", uid)
		return nil, err
	}
	input.UserIDs = append(input.UserIDs, u.ID)
	b, err := r.client.Business.Create().SetInput(input).Save(ctx)
	if err != nil {
		logger.Err(err).Msgf("Error creating business with Name1: '%v'", input.Name1)
		return nil, err
	}
	return b, err
}

// UpdateBusiness is the resolver for the updateBusiness field.
func (r *mutationResolver) UpdateBusiness(ctx context.Context, id uuid.UUID, input ent.UpdateBusinessInput) (*ent.Business, error) {
	// Workaround for Khan/genqlient, since the # @genqlient(omitempty: true) directive will not work and the
	//UpdateBusinessInput ist derived from here
	if *input.Email == "" {
		input.ClearEmail = true
		input.Email = nil
	}
	if *input.Telephone == "" {
		input.ClearEmail = true
		input.Email = nil
	}
	return r.client.Business.UpdateOneID(id).SetInput(input).Save(ctx)
}

// CreateTimetable is the resolver for the createTimetable field.
func (r *mutationResolver) CreateTimetable(ctx context.Context, input ent.CreateTimetableInput) (*ent.Timetable, error) {
	t, err := r.client.Timetable.Create().SetInput(input).Save(ctx)
	return t, err
}

// UpdateTimetable is the resolver for the updateTimetable field.
func (r *mutationResolver) UpdateTimetable(ctx context.Context, id uuid.UUID, input ent.UpdateTimetableInput) (*ent.Timetable, error) {
	return r.client.Timetable.UpdateOneID(id).SetInput(input).Save(ctx)
}

// CreateAddress is the resolver for the createAddress field.
func (r *mutationResolver) CreateAddress(ctx context.Context, input ent.CreateAddressInput) (*ent.Address, error) {
	panic(fmt.Errorf("not implemented: CreateAddress - createAddress"))
}

// UpdateAddress is the resolver for the updateAddress field.
func (r *mutationResolver) UpdateAddress(ctx context.Context, id uuid.UUID, input ent.UpdateAddressInput) (*ent.Address, error) {
	// Workaround, see UpdateBusiness
	if *input.Telephone == "" {
		input.ClearTelephone = true
		input.Telephone = nil
	}
	return r.client.Address.UpdateOneID(id).SetInput(input).Save(ctx)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
